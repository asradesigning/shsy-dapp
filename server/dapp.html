<!--
 * SHSY-RB-2025-Team1
-->
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>SHSY - DApp</title>
        <link
            rel="icon"
            href="https://shsycoin.com/wp-content/uploads/2025/04/cropped-200x200-1-32x32.gif"
            sizes="32x32"
        />
        <link
            rel="icon"
            href="https://shsycoin.com/wp-content/uploads/2025/04/cropped-200x200-1-192x192.gif"
            sizes="192x192"
        />
        <link
            rel="apple-touch-icon"
            href="https://shsycoin.com/wp-content/uploads/2025/04/cropped-200x200-1-180x180.gif"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
            // API Configuration - Force localhost for development
            window.API_BASE_URL =
                window.location.hostname === "localhost" ? "" : "";

            // Buffer polyfill for browser
            window.Buffer = window.Buffer || {
                from: function (data, encoding) {
                    if (encoding === "base64") {
                        const binary = atob(data);
                        const bytes = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) {
                            bytes[i] = binary.charCodeAt(i);
                        }
                        return bytes;
                    }
                    return new Uint8Array(data);
                },
            };

            // Simple API request helper - use current origin
            window.apiRequest = async function (endpoint, options = {}) {
                const url = window.location.origin + endpoint;
                const defaultOptions = {
                    headers: {
                        "Content-Type": "application/json",
                        ...options.headers,
                    },
                    ...options,
                };

                return fetch(url, defaultOptions);
            };
        </script>
        <style>
            body {
                margin: 0;
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                background: linear-gradient(135deg, #d1e7fb 0%, #dffdff 100%);
            }
            .gradient-btn {
                background: linear-gradient(135deg, #00ddeb, #046bd2);
            }
            .gradient-border {
                border-left: 4px solid #00ddeb;
            }
            .light-bg {
                background: rgba(255, 255, 255, 0.9);
            }
            .modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }
            .modal-content {
                background: white;
                padding: 2rem;
                border-radius: 1rem;
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            }
            .spinner {
                border: 2px solid #f3f3f3;
                border-top: 2px solid #00ddeb;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                animation: spin 1s linear infinite;
                display: inline-block;
                margin-right: 8px;
            }
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            /* Additional Responsive Styles for DApp */
            @media (max-width: 768px) {
                .max-w-7xl {
                    padding-left: 12px;
                    padding-right: 12px;
                }

                .grid {
                    grid-template-columns: 1fr;
                    gap: 16px;
                }

                .grid-cols-1 {
                    grid-template-columns: 1fr;
                }

                .grid-cols-2 {
                    grid-template-columns: 1fr;
                }

                .grid-cols-3 {
                    grid-template-columns: 1fr;
                }

                .flex-col {
                    flex-direction: column;
                }

                .space-x-4 > * + * {
                    margin-left: 0;
                    margin-top: 8px;
                }

                .text-xl {
                    font-size: 1.125rem;
                }

                .text-2xl {
                    font-size: 1.25rem;
                }

                .text-3xl {
                    font-size: 1.5rem;
                }

                .px-4 {
                    padding-left: 12px;
                    padding-right: 12px;
                }

                .py-4 {
                    padding-top: 12px;
                    padding-bottom: 12px;
                }

                .mb-6 {
                    margin-bottom: 16px;
                }

                .gap-6 {
                    gap: 16px;
                }
            }

            @media (max-width: 480px) {
                .max-w-7xl {
                    padding-left: 8px;
                    padding-right: 8px;
                }

                .px-4 {
                    padding-left: 8px;
                    padding-right: 8px;
                }

                .py-4 {
                    padding-top: 8px;
                    padding-bottom: 8px;
                }

                .text-lg {
                    font-size: 1rem;
                }

                .text-xl {
                    font-size: 1.125rem;
                }

                .mb-6 {
                    margin-bottom: 12px;
                }

                .gap-6 {
                    gap: 12px;
                }
            }
        </style>
    </head>
    <body class="min-h-screen">
        <!-- Header -->
        <div
            style="
                background: linear-gradient(
                    135deg,
                    #00ddeb 0%,
                    #046bd2 50%,
                    #00ddeb 100%
                );
                border-bottom: 1px solid #00ddeb;
            "
        >
            <div class="max-w-7xl mx-auto px-4 sm:px-6 py-4">
                <!-- Main Header Row -->
                <div class="flex flex-col space-y-3">
                    <!-- Top row: Title and Primary Actions -->
                    <div
                        class="flex flex-col sm:flex-row sm:justify-between sm:items-center space-y-3 sm:space-y-0"
                    >
                        <div class="flex items-center space-x-2 sm:space-x-4">
                            <h1
                                class="text-lg sm:text-xl font-semibold"
                                style="color: white; font-weight: 600"
                            >
                                üöÄ Staking DApp
                            </h1>
                            <button
                                id="backToDashboard"
                                class="hidden sm:flex text-white px-3 py-1 rounded-lg font-medium text-sm transition-all duration-300 items-center gap-2"
                                style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 1px solid rgba(255, 255, 255, 0.3);
                                "
                                onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='scale(1.05)';"
                                onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='scale(1)';"
                                onclick="window.location.href = '/dashboard'"
                            >
                                <svg
                                    width="14"
                                    height="14"
                                    viewBox="0 0 24 24"
                                    fill="currentColor"
                                >
                                    <path
                                        d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
                                    />
                                </svg>
                                Back to Dashboard
                            </button>
                        </div>

                        <!-- Wallet Status and Connect Button (Always visible) -->
                        <div
                            class="flex flex-col sm:flex-row items-stretch sm:items-center space-y-2 sm:space-y-0 sm:space-x-4"
                        >
                            <div
                                id="walletStatus"
                                class="px-3 sm:px-4 py-2 rounded-lg text-center"
                                style="
                                    background-color: rgba(255, 255, 255, 0.2);
                                "
                            >
                                <span
                                    class="text-xs sm:text-sm font-medium"
                                    style="color: rgba(255, 255, 255, 0.9)"
                                    >Wallet Not Connected</span
                                >
                            </div>
                            <button
                                id="connectWallet"
                                class="text-white px-4 py-2 rounded-lg font-medium text-sm sm:text-base transition-all duration-300"
                                style="
                                    background: rgba(255, 255, 255, 0.2);
                                    border: 1px solid rgba(255, 255, 255, 0.3);
                                "
                                onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='scale(1.05)';"
                                onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='scale(1)';"
                            >
                                Connect Wallet
                            </button>
                        </div>
                    </div>

                    <!-- Second row: Additional Action Buttons (Mobile: full width, Desktop: right aligned) -->
                    <div
                        class="flex flex-col sm:flex-row sm:justify-end space-y-2 sm:space-y-0 sm:space-x-3"
                    >
                        <!-- Mobile Back Button -->
                        <button
                            id="backToDashboardMobile"
                            class="sm:hidden text-white px-4 py-2 rounded-lg font-medium text-sm transition-all duration-300 flex items-center justify-center gap-2"
                            style="
                                background: rgba(255, 255, 255, 0.2);
                                border: 1px solid rgba(255, 255, 255, 0.3);
                            "
                            onmouseover="this.style.background='rgba(255, 255, 255, 0.3)';"
                            onmouseout="this.style.background='rgba(255, 255, 255, 0.2)';"
                            onclick="window.location.href = '/dashboard'"
                        >
                            <svg
                                width="14"
                                height="14"
                                viewBox="0 0 24 24"
                                fill="currentColor"
                            >
                                <path
                                    d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
                                />
                            </svg>
                            Back to Dashboard
                        </button>

                        <button
                            id="airdropTokens"
                            class="text-white px-4 py-2 rounded-lg font-medium text-sm sm:text-base hidden transition-all duration-300"
                            style="
                                background: linear-gradient(
                                    135deg,
                                    #4caf50,
                                    #66bb6a
                                );
                            "
                            onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(76, 175, 80, 0.3)';"
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                        >
                            Get Test Tokens (1000 SHSY)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Telegram Button Section -->
        <div class="max-w-7xl mx-auto px-4 sm:px-6 py-3"></div>

        <div class="max-w-7xl mx-auto px-4 sm:px-6 py-4 sm:py-6">
            <!-- Hero Section -->
            <div
                class="bg-white rounded-lg p-4 sm:p-6 lg:p-8 mb-4 sm:mb-6 text-center gradient-border"
            >
                <h1
                    class="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-900 mb-3 sm:mb-4"
                >
                    Stake SHSY Tokens & Earn Rewards
                </h1>
                <p class="text-sm sm:text-base text-gray-600 mb-4 sm:mb-6">
                    Join our staking platform with up to 10% APY and participate
                    in million-Shsy prize pools
                </p>
                <div class="text-xs sm:text-sm text-gray-500">
                    <div class="break-all">
                        Token Address:
                        <span
                            class="font-mono bg-gray-100 px-2 py-1 rounded text-xs"
                            >3pbRHwFCQbLYoqmvWqkwUV4Vn1mnmqHvfGMhwPaxcL7P</span
                        >
                    </div>
                </div>
            </div>

            <!-- Market Overview -->
            <div
                class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-4 sm:mb-6"
            >
                <div class="bg-white rounded-lg p-4 sm:p-6 gradient-border">
                    <div class="flex items-center">
                        <div class="p-2 sm:p-3 rounded light-bg">
                            <span class="text-xl sm:text-2xl">üí∞</span>
                        </div>
                        <div class="ml-3 sm:ml-4">
                            <h3
                                class="text-xs sm:text-sm font-medium text-gray-500"
                            >
                                Total Staked
                            </h3>
                            <p
                                class="text-lg sm:text-2xl font-bold text-gray-900"
                                id="totalStaked"
                            >
                                Loading...
                            </p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg p-4 sm:p-6 gradient-border">
                    <div class="flex items-center">
                        <div class="p-2 sm:p-3 rounded light-bg">
                            <span class="text-xl sm:text-2xl">üìà</span>
                        </div>
                        <div class="ml-3 sm:ml-4">
                            <h3
                                class="text-xs sm:text-sm font-medium text-gray-500"
                            >
                                Current Yield
                            </h3>
                            <p
                                class="text-lg sm:text-2xl font-bold"
                                style="color: #00ddeb"
                            >
                                5.0% APY
                            </p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg p-4 sm:p-6 gradient-border">
                    <div class="flex items-center">
                        <div class="p-2 sm:p-3 rounded light-bg">
                            <span class="text-xl sm:text-2xl">üë•</span>
                        </div>
                        <div class="ml-3 sm:ml-4">
                            <h3
                                class="text-xs sm:text-sm font-medium text-gray-500"
                            >
                                Active Users
                            </h3>
                            <p
                                class="text-lg sm:text-2xl font-bold text-gray-900"
                                id="activeUsers"
                            >
                                Loading...
                            </p>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg p-4 sm:p-6 gradient-border">
                    <div class="flex items-center">
                        <div class="p-2 sm:p-3 rounded light-bg">
                            <span class="text-xl sm:text-2xl">üèÜ</span>
                        </div>
                        <div class="ml-3 sm:ml-4">
                            <h3
                                class="text-xs sm:text-sm font-medium text-gray-500"
                            >
                                Prize Pool
                            </h3>
                            <p
                                class="text-lg sm:text-2xl font-bold"
                                style="color: #00ddeb"
                            >
                                1,000,000 SHSY
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Navigation Tabs -->
            <div class="bg-white rounded-lg p-6 mb-6">
                <div class="flex flex-wrap gap-2 mb-4">
                    <button
                        id="stakingTab"
                        class="px-4 py-2 text-sm font-medium rounded-lg transition-colors"
                        style="background-color: #00c4b4; color: white"
                        onclick="showSection('staking')"
                    >
                        Staking
                    </button>
                    <button
                        id="lockedFundsTab"
                        class="px-4 py-2 text-sm font-medium rounded-lg transition-colors"
                        style="color: #6b7280"
                        onclick="showSection('lockedFunds')"
                    >
                        Locked Funds
                    </button>
                    <button
                        id="leaderboardTab"
                        class="px-4 py-2 text-sm font-medium rounded-lg transition-colors"
                        style="color: #6b7280"
                        onclick="showSection('leaderboard')"
                    >
                        Leaderboard
                    </button>
                </div>
            </div>

            <!-- Staking Section -->
            <div
                id="stakingSection"
                class="grid grid-cols-1 lg:grid-cols-2 gap-6"
            >
                <!-- Staking Interface -->
                <div class="bg-white rounded-lg p-6">
                    <h2 class="text-xl font-bold text-gray-900 mb-6">
                        üöÄ Stake Your Tokens
                    </h2>

                    <div class="space-y-4">
                        <div>
                            <label
                                class="block text-sm font-medium text-gray-700 mb-2"
                                >Amount to Stake</label
                            >
                            <div class="relative">
                                <input
                                    type="number"
                                    id="stakeAmount"
                                    class="w-full p-3 border border-gray-300 rounded-lg pr-20"
                                    placeholder="0.00"
                                    min="0"
                                    max="1000000"
                                    step="0.01"
                                />
                                <span
                                    class="absolute right-3 top-3 text-gray-500"
                                    >SHSY</span
                                >
                            </div>
                            <p class="text-xs text-gray-500 mt-1">
                                Balance: <span id="tokenBalance">0 SHSY</span><br>
                                <span class="text-orange-600">Max total stake per user: 1,000,000 SHSY</span><br>
                                <span id="currentStakeInfo" class="text-blue-600">Current total staked: 0 SHSY</span>
                            </p>
                        </div>

                        <div>
                            <label
                                class="block text-sm font-medium text-gray-700 mb-2"
                                >Lock Period</label
                            >
                            <select
                                id="lockPeriod"
                                class="w-full p-3 border border-gray-300 rounded-lg"
                            >
                                <!-- Options will be populated dynamically from pools API -->
                            </select>
                        </div>

                        <div class="light-bg p-4 rounded-lg">
                            <div class="flex justify-between text-sm">
                                <span>Estimated Rewards:</span>
                                <span
                                    id="estimatedRewards"
                                    class="font-semibold"
                                    >0 SHSY</span
                                >
                            </div>
                            <div class="flex justify-between text-sm mt-2">
                                <span>Unlock Date:</span>
                                <span id="unlockDate" class="font-semibold"
                                    >-</span
                                >
                            </div>
                        </div>

                        <button
                            id="stakeBtn"
                            class="w-full gradient-btn text-white py-3 px-6 rounded-lg font-medium"
                        >
                            Stake Tokens
                        </button>
                    </div>
                </div>

                <!-- Prize Activities -->
                <div class="bg-white rounded-lg p-6 mt-6">
                    <h2 class="text-xl font-bold text-gray-900 mb-6">
                        üéÅ Prize Activities
                    </h2>

                    <div class="space-y-4">
                        <!-- 10-Day Challenge -->
                        <div
                            id="challenge10Day"
                            class="light-bg p-4 rounded-lg border"
                            style="border-color: #e0f7fa"
                        >
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold text-gray-900">
                                    10-Day Grand Prize
                                </h3>
                                <span
                                    id="challenge10Status"
                                    class="text-xs px-2 py-1 rounded-full"
                                    style="
                                        background-color: #f3f4f6;
                                        color: #6b7280;
                                    "
                                >
                                    Please Connect Your Walllet To Participate
                                </span>
                            </div>
                            <br />
                            <div
                                class="flex justify-between text-xs text-gray-500 mb-2"
                            >
                                <span id="challenge10Reward"
                                    >Reward: -- SHSY</span
                                >
                                <span id="challenge10Progress"
                                    >Progress: 0/10 days</span
                                >
                            </div>
                            <div
                                class="w-full bg-gray-200 rounded-full h-2 mb-2"
                            >
                                <div
                                    id="challenge10ProgressBar"
                                    class="h-2 gradient-btn rounded-full transition-all duration-300"
                                    style="width: 0%"
                                ></div>
                            </div>
                            <div
                                id="challenge10Timer"
                                class="text-xs text-gray-500 mb-2"
                                style="display: none"
                            >
                                Time remaining:
                                <span id="challenge10TimeLeft">--</span>
                            </div>
                            <button
                                id="claim10DayReward"
                                class="w-full gradient-btn text-white text-xs py-2 px-3 rounded-lg font-medium"
                                style="display: none"
                            ></button>
                        </div>

                        <!-- 30-Day Challenge -->
                        <div
                            id="challenge30Day"
                            class="light-bg p-4 rounded-lg border"
                            style="border-color: #e0f7fa"
                        >
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold text-gray-900">
                                    30-Day Grand Prize
                                </h3>
                                <span
                                    id="challenge30Status"
                                    class="text-xs px-2 py-1 rounded-full"
                                    style="
                                        background-color: #f3f4f6;
                                        color: #6b7280;
                                    "
                                >
                                    Please Connect Your Walllet To Participate
                                </span>
                            </div>
                            <br />
                            <div
                                class="flex justify-between text-xs text-gray-500 mb-2"
                            >
                                <span id="challenge30Reward"
                                    >Reward: -- SHSY</span
                                >
                                <span id="challenge30Progress"
                                    >Progress: 0/30 days</span
                                >
                            </div>
                            <div
                                class="w-full bg-gray-200 rounded-full h-2 mb-2"
                            >
                                <div
                                    id="challenge30ProgressBar"
                                    class="gradient-btn h-2 rounded-full transition-all duration-300"
                                    style="width: 0%"
                                ></div>
                            </div>
                            <div
                                id="challenge30Timer"
                                class="text-xs text-gray-500 mb-2"
                                style="display: none"
                            >
                                Time remaining:
                                <span id="challenge30TimeLeft">--</span>
                            </div>
                            <button
                                id="claim30DayReward"
                                onclick="claimChallengeReward('30_day')"
                                class="w-full gradient-btn text-white text-xs py-2 px-3 rounded-lg font-medium"
                                style="display: none"
                            >
                                <span id="claim30ButtonText">Claim Reward</span>
                            </button>
                        </div>

                        <!-- Million Dollar Pool -->
                        <div
                            id="millionPoolSection"
                            class="light-bg p-4 rounded-lg border"
                            style="border-color: #e0f7fa; display: none"
                        >
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="font-semibold text-gray-900">
                                    üí∞ Million SHSY Grand Prize
                                </h3>
                                <span
                                    id="millionPoolStatus"
                                    class="text-xs px-2 py-1 rounded-full"
                                    style="
                                        background-color: #f3f4f6;
                                        color: #6b7280;
                                    "
                                >
                                    Loading...
                                </span>
                            </div>
                            <p class="text-xs text-gray-600 mb-3">
                                Participate by depositing USDT or automatically
                                qualify with 100+ SHSY staked
                            </p>

                            <div class="grid grid-cols-2 gap-3 mb-3">
                                <div class="text-center">
                                    <div class="text-xs text-gray-500">
                                        USDT Option
                                    </div>
                                    <div
                                        class="font-semibold"
                                        style="color: #00ddeb"
                                        id="usdtRequirement"
                                    >
                                        $4.00
                                    </div>
                                    <div
                                        class="text-xs text-gray-400"
                                        id="userUsdtBalance"
                                    >
                                        Balance: Loading...
                                    </div>
                                </div>
                                <div class="text-center">
                                    <div class="text-xs text-gray-500">
                                        SHSY Auto-Qualify
                                    </div>
                                    <div
                                        class="font-semibold"
                                        style="color: #00ddeb"
                                        id="shsyRequirement"
                                    >
                                        100 SHSY
                                    </div>
                                    <div
                                        class="text-xs text-gray-400"
                                        id="userShsyStaked"
                                    >
                                        Staked: Loading...
                                    </div>
                                </div>
                            </div>

                            <div class="text-xs text-gray-500 mb-3">
                                <div>
                                    Next Distribution:
                                    <span id="nextDistribution">--</span>
                                </div>
                                <div>
                                    Reward per Winner:
                                    <span id="rewardPerWinner">--</span>
                                </div>
                                <div>
                                    Number of Winners:
                                    <span id="numberOfWinners">--</span>
                                </div>
                            </div>

                            <div class="space-y-2">
                                <div
                                    id="millionPoolConnectMessage"
                                    class="text-center text-xs text-gray-500 py-2"
                                    style="display: block"
                                >
                                    Connect your wallet to check eligibility
                                </div>

                                <button
                                    id="depositUSDTButton"
                                    onclick="depositUSDT()"
                                    class="w-full gradient-btn hover:bg-green-700 text-white text-xs py-2 px-3 rounded-lg font-medium transition-colors"
                                    style="display: none"
                                >
                                    Deposit USDT to Participate
                                </button>

                                <div
                                    id="autoQualifiedMessage"
                                    class="text-center text-xs text-teal-600 font-medium"
                                    style="display: none"
                                >
                                    ‚úì Auto-qualified with 100+ SHSY staked
                                </div>

                                <div
                                    id="millionPoolParticipating"
                                    class="text-center text-xs text-green-600 font-medium"
                                    style="display: none"
                                >
                                    ‚úì Participating in Million Pool
                                </div>

                                <!-- Million Pool Winnings/Claims Section (integrated) -->
                                <div
                                    id="millionPoolClaimsSection"
                                    style="display: none"
                                >
                                    <div
                                        class="border-t border-gray-200 pt-3 mt-3"
                                    >
                                        <div
                                            class="flex items-center justify-between mb-2"
                                        >
                                            <span
                                                class="text-xs font-medium text-gray-700"
                                                >üèÜ Your Winnings</span
                                            >
                                            <button
                                                onclick="loadMillionPoolWinnings()"
                                                class="text-xs text-teal-600 hover:text-teal-700"
                                            >
                                                üîÑ Refresh
                                            </button>
                                        </div>
                                        <div
                                            id="millionPoolClaimsList"
                                            class="space-y-2"
                                        >
                                            <!-- Claims will be loaded here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Staking Records & Rewards History -->
                <div class="space-y-2 bg-white rounded-lg p-6 mt-6">
                    <div class="flex items-center justify-between mb-6">
                        <h2 class="text-xl font-bold text-gray-900">
                            üìä Your Staking Records
                        </h2>
                        <div class="flex space-x-3">
                            <button
                                id="exportCSV"
                                onclick="exportStakingRecords()"
                                class="text-white px-4 py-2 rounded-lg font-medium transition-all duration-300"
                                style="
                                    background: linear-gradient(
                                        135deg,
                                        #64748b,
                                        #475569
                                    );
                                "
                                onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(100, 116, 139, 0.3)';"
                                onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                            >
                                üìä Export CSV
                            </button>
                        </div>
                    </div>

                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead>
                                <tr class="border-b border-gray-200">
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        Amount
                                    </th>
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        APY
                                    </th>
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        Lock Period
                                    </th>
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        Status
                                    </th>
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        Rewards
                                    </th>
                                    <th
                                        class="text-left py-3 px-4 font-medium text-gray-900"
                                    >
                                        Actions
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="stakingRecords">
                                <!-- Stakes will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Million Pool Winnings Section (hidden - now integrated into participation box) -->
            <div
                id="millionPoolWinningsSection"
                class="bg-white rounded-lg p-6 mt-6"
                style="display: none !important"
            >
                <div class="flex items-center justify-between mb-6">
                    <h2 class="text-xl font-bold text-gray-900">
                        üèÜ Million Pool Winnings
                    </h2>
                    <button
                        id="refreshWinnings"
                        onclick="loadMillionPoolWinnings()"
                        class="text-white px-4 py-2 rounded-lg font-medium transition-all duration-300"
                        style="
                            background: linear-gradient(
                                135deg,
                                #00c4b4,
                                #00e5d0
                            );
                        "
                    >
                        üîÑ Refresh
                    </button>
                </div>

                <div
                    id="noWinningsMessage"
                    class="text-center py-8 text-gray-500"
                    style="display: none"
                >
                    <div class="text-4xl mb-3">üéØ</div>
                    <p>
                        No million pool winnings yet. Keep participating for a
                        chance to win!
                    </p>
                </div>

                <div
                    id="winningsTable"
                    class="overflow-x-auto"
                    style="display: none"
                >
                    <table class="w-full">
                        <thead>
                            <tr class="border-b border-gray-200">
                                <th
                                    class="text-left py-3 px-4 font-medium text-gray-900"
                                >
                                    Prize Amount
                                </th>
                                <th
                                    class="text-left py-3 px-4 font-medium text-gray-900"
                                >
                                    Status
                                </th>
                                <th
                                    class="text-left py-3 px-4 font-medium text-gray-900"
                                >
                                    Won Date
                                </th>
                                <th
                                    class="text-left py-3 px-4 font-medium text-gray-900"
                                >
                                    Actions
                                </th>
                            </tr>
                        </thead>
                        <tbody id="winningsRecords">
                            <!-- Winnings will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <!-- Leaderboard Section -->
        <div
            id="leaderboardSection"
            class="container max-w-7xl mx-auto px-4 py-8"
            style="display: none"
        >
            <div class="bg-white rounded-lg shadow-lg p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-800">
                        üèÜ Top Stakers Leaderboard
                    </h2>
                    <button
                        id="refreshLeaderboard"
                        class="text-white gradient-btn px-4 py-2 rounded-lg font-medium transition-all duration-300"
                        onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0, 196, 180, 0.3)';"
                        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                    >
                        Refresh
                    </button>
                </div>

                <div
                    class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                    id="leaderboardGrid"
                >
                    <!-- Leaderboard items will be populated here -->
                    <div class="border rounded-lg p-4 text-center">
                        <div class="text-2xl mb-2">ü•á</div>
                        <div class="font-bold text-lg">Loading...</div>
                        <div class="text-sm text-gray-600">
                            Fetching top stakers...
                        </div>
                        <div class="text-lg font-semibold text-green-600 mt-2">
                            - SHSY
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Locked Funds Section -->
        <div
            class="container max-w-7xl mx-auto px-4 py-8"
            id="lockedFundsSection"
            style="display: none"
        >
            <div class="bg-white rounded-lg shadow-lg p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-800">
                        üîí Locked Funds Management
                    </h2>
                    <button
                        id="refreshLockedFunds"
                        class="text-white px-4 gradient-btn py-2 rounded-lg font-medium transition-all duration-300"
                        onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0, 196, 180, 0.3)';"
                        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                        onclick="loadLockedFunds()"
                    >
                        Refresh
                    </button>
                </div>

                <!-- Summary Cards -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div
                        class="bg-blue-50 border border-blue-200 rounded-lg p-4"
                    >
                        <div class="text-blue-600 text-sm font-medium">
                            Total Locked
                        </div>
                        <div
                            class="text-2xl font-bold text-blue-800"
                            id="totalLockedAmount"
                        >
                            0 SHSY
                        </div>
                    </div>
                    <div
                        class="bg-green-50 border border-green-200 rounded-lg p-4"
                    >
                        <div class="text-green-600 text-sm font-medium">
                            Available to Unlock
                        </div>
                        <div
                            class="text-2xl font-bold text-green-800"
                            id="totalUnlockableAmount"
                        >
                            0 SHSY
                        </div>
                    </div>
                    <div
                        class="bg-purple-50 border border-purple-200 rounded-lg p-4"
                    >
                        <div class="text-purple-600 text-sm font-medium">
                            Total Records
                        </div>
                        <div
                            class="text-2xl font-bold text-purple-800"
                            id="totalLockedCount"
                        >
                            0
                        </div>
                    </div>
                </div>

                <!-- Locked Funds List -->
                <div class="space-y-4" id="lockedFundsList">
                    <!-- Locked funds will be populated here -->
                    <div
                        class="border rounded-lg p-4 text-center text-gray-500"
                    >
                        <div class="text-lg mb-2">üîç</div>
                        <div>No locked funds found</div>
                        <div class="text-sm">
                            Locked portions of your rewards will appear here
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wallet Connection Modal -->
        <div id="walletModal" class="modal">
            <div class="modal-content">
                <h2 class="text-xl font-bold mb-4">Connect Your Wallet</h2>
                <p class="text-gray-600 mb-6">
                    Connect your Solana wallet to start staking SHSY tokens
                </p>
                <div class="space-y-3">
                    <button
                        id="connectPhantom"
                        class="w-full bg-purple-600 hover:bg-purple-700 text-white py-3 px-4 rounded-lg font-medium flex items-center justify-center"
                    >
                        <span class="w-5 h-5 mr-2 text-xl">üëª</span>
                        Connect Phantom Wallet
                    </button>
                    <button
                        id="connectSolflare"
                        class="w-full bg-orange-600 hover:bg-orange-700 text-white py-3 px-4 rounded-lg font-medium flex items-center justify-center"
                    >
                        <span class="w-5 h-5 mr-2 text-xl">üî•</span>
                        Connect Solflare Wallet
                    </button>
                </div>
                <button
                    onclick="closeWalletModal()"
                    class="w-full mt-4 bg-gray-300 hover:bg-gray-400 text-gray-700 py-2 px-4 rounded-lg"
                >
                    Cancel
                </button>
            </div>
        </div>

        <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
        <script>
            // Import necessary classes from Solana web3
            const { Connection, Transaction, PublicKey } = solanaWeb3;

            // Initialize connection to devnet
            const connection = new Connection(
                "https://api.devnet.solana.com",
                "confirmed",
            );

            let walletConnected = false;
            let walletAddress = null;
            let currentWallet = null; // For million pool functions
            let tokenBalance = 0;
            let stakingChallenges = [];
            let challengeEligibility = {
                isEligible: false,
                hasStakes: false,
                hasGuesses: false,
                message:
                    "Please stake some tokens or answer riddles to participate in the reward",
            };
            let pendingRewards = [];
            let lockedFunds = [];
            let lockedFundsSummary = {
                totalLocked: "0",
                totalUnlockable: "0",
                totalCount: 0,
                unlockableCount: 0,
            };

            // Wallet connection functions
            function showWalletModal() {
                document.getElementById("walletModal").style.display = "flex";
            }

            function closeWalletModal() {
                document.getElementById("walletModal").style.display = "none";
            }

            async function connectWallet(walletType) {
                try {
                    let provider;

                    console.log("Attempting to connect wallet:", walletType);
                    console.log(
                        "Window object contains:",
                        Object.keys(window).filter((key) =>
                            key.toLowerCase().includes("sol"),
                        ),
                    );
                    console.log("Available providers:", {
                        solana: !!window.solana,
                        solflare: !!window.solflare,
                        isPhantom: window.solana?.isPhantom,
                        isSolflare:
                            window.solana?.isSolflare ||
                            window.solflare?.isSolflare,
                        solanaKeys: window.solana
                            ? Object.keys(window.solana)
                            : [],
                        solflareKeys: window.solflare
                            ? Object.keys(window.solflare)
                            : [],
                    });

                    if (walletType === "phantom") {
                        if (window.solana && window.solana.isPhantom) {
                            provider = window.solana;
                        } else {
                            window.open("https://phantom.app/", "_blank");
                            alert(
                                "Please install Phantom wallet extension and refresh the page",
                            );
                            return;
                        }
                    } else if (walletType === "solflare") {
                        // Wait a bit for wallet injection
                        await new Promise((resolve) =>
                            setTimeout(resolve, 100),
                        );

                        // Check multiple possible injection points
                        if (window.solflare) {
                            provider = window.solflare;
                            console.log("Using window.solflare provider");
                        } else if (window.solana && window.solana.isSolflare) {
                            provider = window.solana;
                            console.log(
                                "Using window.solana with isSolflare flag",
                            );
                        } else if (window.solana && !window.solana.isPhantom) {
                            // Ask user if they want to try with detected wallet
                            const tryAnyway = confirm(
                                "Detected a Solana wallet that might be Solflare. Try connecting?",
                            );
                            if (tryAnyway) {
                                provider = window.solana;
                                console.log("Using generic solana provider");
                            } else {
                                window.open("https://solflare.com/", "_blank");
                                alert(
                                    "Please install Solflare wallet extension and refresh the page",
                                );
                                return;
                            }
                        } else {
                            alert(
                                "Solflare wallet not detected. Please make sure Solflare extension is installed and enabled, then refresh the page.",
                            );
                            window.open("https://solflare.com/", "_blank");
                            return;
                        }
                    }

                    if (!provider) {
                        throw new Error("Wallet provider not found");
                    }

                    console.log(
                        "Provider found, attempting connection with provider:",
                        provider,
                    );

                    // Check if provider has connect method
                    if (typeof provider.connect !== "function") {
                        throw new Error(
                            "Provider does not have connect method",
                        );
                    }

                    // Check if we can detect network configuration
                    const connection = new solanaWeb3.Connection(
                        "https://api.devnet.solana.com",
                        "confirmed",
                    );

                    // Attempt to verify network compatibility
                    try {
                        const version = await connection.getVersion();
                        console.log(
                            "Connected to Solana devnet, version:",
                            version,
                        );
                    } catch (networkError) {
                        console.warn("Network connection issue:", networkError);
                    }

                    const response = await provider.connect({
                        onlyIfTrusted: false,
                    });
                    console.log("Connection response:", response);

                    // Different wallets return different response formats
                    let publicKey = null;

                    if (response === true && provider.publicKey) {
                        // Solflare returns true and stores publicKey on the provider
                        publicKey = provider.publicKey;
                    } else if (response && response.publicKey) {
                        // Phantom returns an object with publicKey
                        publicKey = response.publicKey;
                    } else if (provider.publicKey) {
                        // Fallback: check provider directly
                        publicKey = provider.publicKey;
                    }

                    console.log("Extracted public key:", publicKey);

                    if (publicKey) {
                        walletAddress = publicKey.toString();
                        currentWallet = walletAddress; // Set currentWallet for million pool functions
                        walletConnected = true;

                        // Store the connected provider globally for transaction signing
                        window.connectedWalletProvider = provider;

                        // Ensure window.solana points to the connected provider for compatibility
                        if (provider !== window.solana) {
                            window.solana = provider;
                            console.log(
                                "Assigned connected provider to window.solana",
                            );
                        }

                        console.log(
                            "Wallet connected successfully:",
                            walletAddress,
                        );

                        // Call backend to register/get user
                        try {
                            const userResponse = await apiRequest(
                                "/api/connect-wallet",
                                {
                                    method: "POST",
                                    body: JSON.stringify({ walletAddress }),
                                },
                            );

                            if (userResponse.ok) {
                                const userData = await userResponse.json();
                                console.log("User registered:", userData);
                            }
                        } catch (backendError) {
                            console.warn(
                                "Backend registration failed, but wallet connected:",
                                backendError,
                            );
                        }

                        updateWalletUI();
                        closeWalletModal();
                        await fetchTokenBalance();
                        await loadUserStakes();

                        // Load million pool data after wallet connection
                        console.log(
                            "Wallet connected, loading million pool settings...",
                        );
                        await loadMillionPoolSettings(); // Ensure settings are loaded
                        if (
                            millionPoolSettings &&
                            millionPoolSettings.isActive
                        ) {
                            console.log(
                                "Million pool is active, checking eligibility...",
                            );
                            await checkMillionPoolEligibility();
                            await loadUserBalances();
                            await loadMillionPoolWinnings(); // Load winnings after wallet connects
                        }

                        // Load staking challenges
                        await loadStakingChallenges();
                        startChallengeTimers();
                    } else {
                        throw new Error(
                            "No public key received from wallet. Response: " +
                                JSON.stringify(response),
                        );
                    }
                } catch (error) {
                    console.error("Wallet connection failed:", error);
                    console.error("Error details:", {
                        name: error.name,
                        message: error.message,
                        stack: error.stack,
                    });

                    let errorMessage = "Failed to connect wallet. ";

                    if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Connection was cancelled by user.";
                    } else if (
                        error.message &&
                        error.message.includes("not found")
                    ) {
                        errorMessage +=
                            "Wallet not detected. Please install the wallet extension.";
                    } else if (
                        error.message &&
                        error.message.includes("connect method")
                    ) {
                        errorMessage +=
                            "Wallet provider is not properly initialized. Try refreshing the page.";
                    } else {
                        errorMessage += `Error: ${error.message}. Please check console for details.`;
                    }

                    alert(errorMessage);
                }
            }

            function updateWalletUI() {
                const statusElement = document.getElementById("walletStatus");
                const connectButton = document.getElementById("connectWallet");

                if (walletConnected && walletAddress) {
                    statusElement.className =
                        "bg-green-100 px-4 py-2 rounded-lg";
                    statusElement.innerHTML =
                        '<span class="text-sm font-medium text-green-700">Connected: ' +
                        walletAddress.substring(0, 4) +
                        "..." +
                        walletAddress.substring(walletAddress.length - 4) +
                        "</span>";
                    connectButton.textContent = "Disconnect";
                    connectButton.onclick = disconnectWallet;
                    document
                        .getElementById("airdropTokens")
                        .classList.remove("hidden");
                } else {
                    statusElement.className = "bg-red-100 px-4 py-2 rounded-lg";
                    statusElement.innerHTML =
                        '<span class="text-sm font-medium text-red-700">Wallet Not Connected</span>';
                    connectButton.textContent = "Connect Wallet";
                    connectButton.onclick = showWalletModal;
                    document
                        .getElementById("airdropTokens")
                        .classList.add("hidden");
                }
            }

            function disconnectWallet() {
                walletConnected = false;
                walletAddress = null;
                currentWallet = null;
                tokenBalance = 0;
                updateWalletUI();
                document.getElementById("tokenBalance").textContent = "0 SHSY";

                // Reset million pool display to show connect message
                if (millionPoolSettings && millionPoolSettings.isActive) {
                    updateMillionPoolDisplay();
                }
            }

            async function fetchTokenBalance() {
                if (!walletConnected || !walletAddress) return;

                try {
                    console.log(
                        "Fetching SHSY token balance for wallet:",
                        walletAddress,
                    );
                    const response = await apiRequest(
                        `/api/dapp/balance/${walletAddress}`,
                    );
                    const data = await response.json();
                    console.log("Token balance response:", data);

                    if (
                        response.ok &&
                        data &&
                        data.success &&
                        data.balance !== undefined
                    ) {
                        tokenBalance = parseFloat(data.balance) || 0;
                        solBalance = 0; // Not relevant for devnet testing
                        sufficientSOL = true; // Always sufficient for devnet

                        console.log(
                            `SHSY token balance found: ${tokenBalance}`,
                        );
                        document.getElementById("tokenBalance").textContent =
                            tokenBalance.toFixed(2) + " SHSY";

                        // Show SOL balance info if insufficient for fees
                        if (!sufficientSOL) {
                            showNotification(
                                "Insufficient SOL for transaction fees. Please add SOL to your wallet.",
                                "warning",
                            );
                        }

                        // Show success message for first-time detection
                        if (tokenBalance > 0) {
                            showNotification(
                                `SHSY tokens detected: ${tokenBalance.toFixed(2)} SHSY`,
                                "success",
                            );
                        } else {
                            showNotification(
                                'No tokens in wallet. Click "Get Test Tokens" to receive 1000 SHSY for testing.',
                                "info",
                            );
                        }
                    } else {
                        console.log("Token balance API error:", data);
                        tokenBalance = 0;
                        document.getElementById("tokenBalance").textContent =
                            "0 SHSY";

                        if (data && data.error) {
                            showNotification(
                                "Error fetching token balance: " + data.error,
                                "error",
                            );
                        } else {
                            showNotification(
                                'Click "Get Test Tokens" to receive 1000 SHSY for testing.',
                                "info",
                            );
                        }
                    }
                } catch (error) {
                    console.error("Failed to fetch SHSY token balance:", error);
                    document.getElementById("tokenBalance").textContent =
                        "0 SHSY";
                    showNotification(
                        "Unable to connect to SHSY token contract on Solana mainnet",
                        "error",
                    );
                }
            }

            async function loadUserStakes() {
                console.log(
                    "loadUserStakes called, walletConnected:",
                    walletConnected,
                    "walletAddress:",
                    walletAddress,
                );
                if (!walletConnected || !walletAddress) {
                    console.log("Wallet not connected, skipping stake loading");
                    return;
                }

                try {
                    console.log(
                        "Fetching stakes from API for wallet:",
                        walletAddress,
                    );
                    const response = await apiRequest(
                        `/api/dapp/stakes/${walletAddress}?page=${currentStakingPage}&limit=${stakingRecordsPerPage}`,
                    );
                    console.log("API response status:", response.status);
                    if (response.ok) {
                        const data = await response.json();
                        console.log("API response data:", data);
                        // Update staking table with pagination support
                        const pagination = data.pagination || {
                            page: 1,
                            totalPages: 1,
                            totalStakes: data.stakes?.length || 0,
                        };
                        updateStakingTable(data.stakes || [], pagination);
                    } else {
                        console.error("API response not ok:", response.status);
                    }
                } catch (error) {
                    console.error("Failed to load user stakes:", error);
                }
            }

            // Add pagination variables for staking records
            let currentStakingPage = 1;
            const stakingRecordsPerPage = 10;

            function updateStakingTable(stakes, pagination = null) {
                console.log("updateStakingTable called with stakes:", stakes);
                const tbody = document.getElementById("stakingRecords");
                console.log("Found tbody element:", !!tbody);

                if (!tbody) {
                    console.error("stakingRecords table body not found");
                    return;
                }

                if (stakes.length === 0) {
                    console.log("No stakes to display");
                    tbody.innerHTML =
                        '<tr><td colspan="6" class="text-center py-4 text-gray-500">No stakes found</td></tr>';

                    // Remove pagination controls if no stakes
                    const existingPagination = document.getElementById(
                        "stakingPaginationControls",
                    );
                    if (existingPagination) {
                        existingPagination.remove();
                    }
                    return;
                }

                tbody.innerHTML = "";
                console.log("Processing", stakes.length, "stakes");

                // [M-01 FIX] Calculate total staked amount for user validation
                let totalStaked = 0;
                stakes.forEach((stake) => {
                    totalStaked += parseFloat(stake.amount) || 0;
                });
                window.userTotalStaked = totalStaked;
                
                // Update current stake info display
                const currentStakeInfo = document.getElementById("currentStakeInfo");
                if (currentStakeInfo) {
                    const remainingCapacity = 1000000 - totalStaked;
                    currentStakeInfo.textContent = `Current total staked: ${totalStaked.toFixed(2)} SHSY (${remainingCapacity.toFixed(2)} capacity remaining)`;
                    currentStakeInfo.className = totalStaked > 900000 ? "text-red-600" : "text-blue-600";
                }

                stakes.forEach((stake) => {
                    const row = document.createElement("tr");
                    row.className = "border-b border-gray-100";

                    // Use manual lock period from database
                    const lockPeriodDays = stake.lockPeriodDays || 30;

                    // Get current APY rate from loaded pools data (admin settings)
                    const currentPool = stakingPools.find(
                        (pool) => pool.lockPeriod === lockPeriodDays,
                    );
                    const apyRate = currentPool
                        ? currentPool.apy
                        : stake.apyRate || 5.0;

                    const lockedUntil = new Date(
                        stake.lockedUntil || stake.createdAt,
                    );

                    // Production: use actual days for lock periods
                    let lockPeriodSeconds = lockPeriodDays * 24 * 60 * 60; // Convert days to seconds for production
                    let lockPeriodDisplay = `${lockPeriodDays} Days`; // Show as days for production

                    // Calculate time remaining using lockedUntil from database
                    const now = new Date();
                    const stakeTime = new Date(stake.createdAt);
                    const elapsedSeconds = Math.floor(
                        (now.getTime() - stakeTime.getTime()) / 1000,
                    );

                    // Use lockedUntil from database for accurate remaining time
                    const remainingSeconds = Math.max(
                        0,
                        Math.floor(
                            (lockedUntil.getTime() - now.getTime()) / 1000,
                        ),
                    );

                    // Format time display dynamically
                    function formatTimeDisplay(seconds) {
                        if (seconds <= 0) return "Unlocked";

                        const days = Math.floor(seconds / 86400);
                        const hours = Math.floor((seconds % 86400) / 3600);
                        const mins = Math.floor((seconds % 3600) / 60);
                        const secs = seconds % 60;

                        if (days > 0) {
                            return `${days}d ${hours}h`;
                        } else if (hours > 0) {
                            return `${hours}h ${mins}m`;
                        } else if (mins > 0) {
                            return `${mins}m ${secs}s`;
                        } else {
                            return `${secs}s`;
                        }
                    }

                    // Determine status and action based on time and database status
                    let status, action;
                    if (stake.status === "withdrawn") {
                        status =
                            '<span class="bg-gray-100 text-gray-700 px-2 py-1 rounded-full text-xs">Withdrawn</span>';
                        action =
                            '<span class="text-gray-400 text-sm">Claimed</span>';
                    } else if (
                        stake.status === "completed" ||
                        stake.status === "unlocked" ||
                        remainingSeconds === 0
                    ) {
                        status =
                            '<span class="bg-blue-100 text-blue-700 px-2 py-1 rounded-full text-xs">Ready to Withdraw</span>';
                        action = `<button onclick="withdrawStake(${stake.id}, ${parseFloat(stake.amount)})" class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600">Withdraw</button>`;
                    } else {
                        const timeDisplay = formatTimeDisplay(remainingSeconds);
                        status = `<span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded-full text-xs">Locked (${timeDisplay})</span>`;
                        action = `<span class="text-gray-400 text-sm">Wait ${timeDisplay}</span>`;
                    }

                    // Calculate pending rewards based on APY and time elapsed
                    const principal = parseFloat(stake.amount);
                    const timeElapsedInYears =
                        elapsedSeconds / (365 * 24 * 60 * 60); // Convert seconds to years for APY calculation
                    const pendingRewards = (
                        principal *
                        (apyRate / 100) *
                        timeElapsedInYears
                    ).toFixed(8);

                    row.innerHTML = `
                    <td class="py-3 px-4">${parseFloat(stake.amount).toFixed(8)} SHSY</td>
                    <td class="py-3 px-4">${apyRate}%</td>
                    <td class="py-3 px-4">${lockPeriodDisplay}</td>
                    <td class="py-3 px-4">${status}</td>
                    <td class="py-3 px-4">${pendingRewards} SHSY</td>
                    <td class="py-3 px-4">${action}</td>
                `;

                    tbody.appendChild(row);
                });

                // Add pagination controls if provided
                if (pagination && pagination.totalPages > 1) {
                    updateStakingPagination(
                        pagination.page,
                        pagination.totalPages,
                        pagination.totalStakes,
                    );
                }
            }

            function updateStakingPagination(page, totalPages, totalRecords) {
                const existingPagination = document.getElementById(
                    "stakingPaginationControls",
                );
                if (existingPagination) {
                    existingPagination.remove();
                }

                if (totalPages > 1) {
                    const paginationDiv = document.createElement("div");
                    paginationDiv.id = "stakingPaginationControls";
                    paginationDiv.className =
                        "flex items-center justify-between mt-4 pt-4 border-t border-gray-200";
                    paginationDiv.innerHTML = `
                        <div class="text-sm text-gray-600">
                            Showing page ${page} of ${totalPages} (${totalRecords} total records)
                        </div>
                        <div class="flex items-center space-x-2">
                            <button onclick="changeStakingPage(${page - 1})" 
                                    ${page <= 1 ? "disabled" : ""} 
                                    class="px-3 py-1 text-white rounded text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                                    style="background: linear-gradient(135deg, #00ddeb, #046bd2);">
                                Previous
                            </button>
                            <span class="px-2 text-sm text-gray-600">${page}</span>
                            <button onclick="changeStakingPage(${page + 1})" 
                                    ${page >= totalPages ? "disabled" : ""} 
                                    class="px-3 py-1 text-white rounded text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                                    style="background: linear-gradient(135deg, #00ddeb, #046bd2);">
                                Next
                            </button>
                        </div>
                    `;

                    // Insert after the staking table
                    const stakingTable = document
                        .querySelector("#stakingRecords")
                        .closest("table");
                    stakingTable.parentNode.appendChild(paginationDiv);
                }
            }

            function changeStakingPage(newPage) {
                console.log(`Attempting to change to page ${newPage}, current page: ${currentStakingPage}`);
                
                // Get total pages from existing pagination controls
                const paginationControls = document.getElementById("stakingPaginationControls");
                let totalPages = 1;
                if (paginationControls) {
                    const pageInfo = paginationControls.querySelector('.text-sm.text-gray-600');
                    if (pageInfo && pageInfo.textContent) {
                        const match = pageInfo.textContent.match(/page \d+ of (\d+)/);
                        if (match) {
                            totalPages = parseInt(match[1]);
                        }
                    }
                }
                
                // Validate page bounds
                if (newPage >= 1 && newPage <= totalPages) {
                    currentStakingPage = newPage;
                    console.log(`Updated currentStakingPage to: ${currentStakingPage} (max: ${totalPages})`);
                    console.log(`Loading data for page ${currentStakingPage}...`);
                    loadUserStakes();
                } else {
                    console.log(`Invalid page number: ${newPage} (valid range: 1-${totalPages})`);
                }
            }

            // Enhanced test function to check pagination
            window.testPagination = function() {
                console.log("=== PAGINATION TEST ===");
                console.log(`- currentStakingPage: ${currentStakingPage}`);
                console.log(`- stakingRecordsPerPage: ${stakingRecordsPerPage}`);
                console.log(`- Wallet connected: ${walletConnected}`);
                console.log(`- Wallet address: ${walletAddress}`);
                
                const paginationControls = document.getElementById("stakingPaginationControls");
                if (paginationControls) {
                    console.log("‚úì Pagination controls found");
                    console.log("- Controls HTML:", paginationControls.innerHTML.substring(0, 100) + "...");
                } else {
                    console.log("‚úó Pagination controls NOT found");
                }
                
                console.log("Testing navigation to page 2...");
                changeStakingPage(2);
            };

            function calculateRewards() {
                const amount =
                    parseFloat(document.getElementById("stakeAmount").value) ||
                    0;
                const lockPeriod = parseInt(
                    document.getElementById("lockPeriod").value,
                );

                // Use exact smart contract reward calculation (basis points)
                let rewardRate = 500; // 5% for 30 seconds (500 basis points)
                if (lockPeriod === 45) rewardRate = 500; // 5% for 45 seconds (500 basis points)
                if (lockPeriod === 60) rewardRate = 500; // 5% for 60 seconds (500 basis points)

                // Calculate rewards using smart contract formula
                const rewards = (amount * rewardRate) / 10000;

                document.getElementById("estimatedRewards").textContent =
                    rewards.toFixed(6) + " SHSY";

                // Show unlock time in seconds for testing
                const unlockDate = new Date(Date.now() + lockPeriod * 1000);
                document.getElementById("unlockDate").textContent =
                    unlockDate.toLocaleTimeString();
            }

            let isStaking = false; // Global flag to prevent multiple staking calls
            let isWithdrawing = false; // Global flag to prevent multiple withdrawal calls

            async function stakeTokens() {
                // Prevent multiple simultaneous calls
                if (isStaking) {
                    console.log(
                        "Staking already in progress, ignoring duplicate call",
                    );
                    return;
                }

                if (!walletConnected) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                const amount = parseFloat(
                    document.getElementById("stakeAmount").value,
                );
                if (!amount || amount <= 0) {
                    showNotification("Please enter a valid amount", "error");
                    return;
                }

                if (amount > tokenBalance) {
                    showNotification(
                        "Insufficient SHSY token balance",
                        "error",
                    );
                    return;
                }

                // [M-01 FIX] Check maximum stake per user limit (1M tokens)
                const currentTotalStaked = window.userTotalStaked || 0;
                const maxStakePerUser = 1000000; // 1M tokens
                if (currentTotalStaked + amount > maxStakePerUser) {
                    const remainingCapacity = maxStakePerUser - currentTotalStaked;
                    showNotification(
                        `Maximum stake exceeded. You can stake up to ${remainingCapacity.toFixed(2)} more SHSY (${maxStakePerUser.toLocaleString()} max total per user)`,
                        "error",
                    );
                    return;
                }

                // Set flag to prevent multiple calls
                isStaking = true;

                const stakeBtn = document.getElementById("stakeBtn");
                stakeBtn.innerHTML =
                    '<div class="spinner"></div>Creating Transaction...';
                stakeBtn.disabled = true;

                const lockPeriod = parseInt(
                    document.getElementById("lockPeriod").value,
                );
                const poolId =
                    lockPeriod === 30 ? 1 : lockPeriod === 90 ? 2 : 3;

                let createResult = null;
                let stakeIndex = null;

                try {
                    // Step 1: Create smart contract transaction
                    showNotification(
                        "Creating smart contract transaction...",
                        "info",
                    );

                    const createResponse = await apiRequest(
                        "/api/dapp/stake/create-transaction",
                        {
                            method: "POST",
                            body: JSON.stringify({
                                walletAddress,
                                amount,
                                poolId,
                            }),
                        },
                    );

                    if (!createResponse.ok) {
                        const error = await createResponse.json();
                        throw new Error(
                            error.error || "Failed to create transaction",
                        );
                    }

                    createResult = await createResponse.json();
                    const { transactionData } = createResult;
                    stakeIndex = createResult.stakingDetails.stakeIndex;
                    console.log(
                        "Smart contract transaction created:",
                        transactionData.instructions,
                    );

                    // Step 2: Get wallet provider for signing
                    let provider;

                    // Check if we have a stored provider from connection
                    if (window.connectedWalletProvider) {
                        provider = window.connectedWalletProvider;
                        console.log("Using stored wallet provider");
                    } else if (window.solflare && window.solflare.isSolflare) {
                        provider = window.solflare;
                    } else if (window.solana && window.solana.isPhantom) {
                        provider = window.solana;
                    } else if (window.solana) {
                        // Fallback to any available Solana provider
                        provider = window.solana;
                    } else {
                        throw new Error(
                            "No wallet provider found. Please install Phantom or Solflare wallet.",
                        );
                    }

                    // Verify provider is still connected
                    if (
                        !provider.isConnected &&
                        typeof provider.isConnected !== "undefined"
                    ) {
                        throw new Error(
                            "Wallet not connected. Please reconnect your wallet and try again.",
                        );
                    }

                    // Ensure we have a valid public key
                    if (!provider.publicKey) {
                        // Try to reconnect silently
                        try {
                            await provider.connect({ onlyIfTrusted: true });
                        } catch (reconnectError) {
                            throw new Error(
                                "Wallet connection lost. Please reconnect your wallet and try again.",
                            );
                        }
                    }

                    // Final verification
                    if (
                        !provider.publicKey ||
                        provider.publicKey.toString() !== walletAddress
                    ) {
                        throw new Error(
                            "Wallet address mismatch. Please reconnect your wallet and try again.",
                        );
                    }

                    // Step 3: User signs the transaction
                    showNotification(
                        "Please approve the transaction in your wallet...",
                        "info",
                    );
                    stakeBtn.innerHTML =
                        '<div class="spinner"></div>Awaiting Signature...';

                    // Create devnet connection first
                    const devnetConnection = new solanaWeb3.Connection(
                        "https://api.devnet.solana.com",
                        "confirmed",
                    );

                    // Get fresh devnet blockhash for the transaction
                    const { blockhash } =
                        await devnetConnection.getLatestBlockhash("finalized");

                    // Deserialize the transaction
                    const transaction = solanaWeb3.Transaction.from(
                        Buffer.from(
                            transactionData.serializedTransaction,
                            "base64",
                        ),
                    );

                    // Update transaction with fresh devnet blockhash
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = new solanaWeb3.PublicKey(
                        walletAddress,
                    );

                    // Sign transaction with wallet
                    let signedTransaction;
                    try {
                        console.log(
                            "Attempting to sign transaction with provider:",
                            {
                                isPhantom: provider.isPhantom,
                                isSolflare: provider.isSolflare,
                                isConnected: provider.isConnected,
                                publicKey: provider.publicKey?.toString(),
                                hasSignTransaction:
                                    typeof provider.signTransaction ===
                                    "function",
                            },
                        );

                        signedTransaction =
                            await provider.signTransaction(transaction);
                        console.log("Transaction signed successfully");
                    } catch (signError) {
                        console.error("Transaction signing failed:", signError);

                        if (
                            signError.message &&
                            signError.message.includes("Not connected")
                        ) {
                            throw new Error(
                                "Wallet connection lost during signing. Please reconnect your wallet and try again.",
                            );
                        } else if (
                            signError.message &&
                            signError.message.toLowerCase().includes("network")
                        ) {
                            throw new Error(
                                "Network mismatch: Please switch your wallet to Solana Devnet network and try again.",
                            );
                        } else if (
                            signError.message &&
                            signError.message.includes("User rejected")
                        ) {
                            throw new Error(
                                "Transaction was cancelled by user.",
                            );
                        }
                        throw signError;
                    }

                    // Step 4: Send signed transaction to blockchain
                    showNotification(
                        "Broadcasting transaction to blockchain...",
                        "info",
                    );
                    stakeBtn.innerHTML =
                        '<div class="spinner"></div>Broadcasting...';

                    // Use the same devnet connection for broadcasting with retry logic
                    const connection = devnetConnection;

                    // Transaction is already unique due to recent blockhash - use as-is
                    console.log("Using transaction as created by backend (no modifications needed)");

                    // Send transaction with improved retry logic
                    let signature;
                    try {
                        signature = await connection.sendRawTransaction(
                            signedTransaction.serialize(),
                            {
                                skipPreflight: false,
                                preflightCommitment: "confirmed",
                                maxRetries: 3,
                            },
                        );
                    } catch (sendError) {
                        console.error("Transaction send error:", sendError);
                        throw new Error(
                            `Transaction failed: ${sendError.message}`,
                        );
                    }

                    // Step 5: Confirm transaction if we have a signature
                    if (signature) {
                        showNotification("Confirming transaction...", "info");

                        try {
                            await connection.confirmTransaction(
                                signature,
                                "confirmed",
                            );
                            console.log(
                                "Transaction confirmed with signature:",
                                signature,
                            );
                        } catch (confirmError) {
                            console.log(
                                "Confirmation skipped - transaction may already be processed",
                            );
                            // Don't throw error for confirmation failures
                        }
                    }

                    // Step 6: Record stake in backend
                    showNotification("Recording stake in database...", "info");
                    stakeBtn.innerHTML =
                        '<div class="spinner"></div>Recording...';

                    // Add wallet type debugging
                    const walletType = provider.isPhantom
                        ? "Phantom"
                        : provider.isSolflare
                          ? "Solflare"
                          : "Unknown";
                    console.log(`Recording stake for ${walletType} wallet:`, {
                        walletAddress,
                        amount,
                        poolId,
                        signature,
                        walletType,
                    });

                    try {
                        const confirmResponse = await fetch(
                            "/api/dapp/stake/confirm",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    walletAddress,
                                    amount,
                                    poolId,
                                    transactionSignature: signature,
                                }),
                            },
                        );

                        console.log(
                            `Database save response status for ${walletType}:`,
                            confirmResponse.status,
                        );

                        if (!confirmResponse.ok) {
                            const errorData = await confirmResponse.json();
                            console.error(
                                `Database save failed for ${walletType}:`,
                                errorData,
                            );
                            throw new Error(
                                errorData.error ||
                                    "Failed to save stake to database",
                            );
                        }

                        const confirmData = await confirmResponse.json();
                        console.log(
                            `Stake saved to database for ${walletType}:`,
                            confirmData,
                        );

                        showNotification(
                            `Stake successful! ${amount} SHSY staked with ${
                                poolId === 0 ? "5%" : poolId === 1 ? "6%" : "7%"
                            } APY for ${
                                poolId === 0
                                    ? "30"
                                    : poolId === 1
                                      ? "90"
                                      : "180"
                            } days`,
                            "success",
                        );

                        // Reset form and refresh data
                        document.getElementById("stakeAmount").value = "";
                        await fetchTokenBalance();
                        await loadUserStakes();
                    } catch (confirmError) {
                        console.error(
                            `Error saving ${walletType} stake to database:`,
                            confirmError,
                        );

                        // Even if database save fails, the blockchain transaction succeeded
                        showNotification(
                            `Stake transaction successful but database save failed. Transaction: ${signature}`,
                            "warning",
                        );

                        // Log the failure but don't auto-recover to avoid constant attempts
                        console.log(
                            `Database save failed for ${walletType} wallet. Transaction signature: ${signature}`,
                        );
                        
                        // Just refresh the data to check if stake was saved despite the error
                        await fetchTokenBalance();
                        await loadUserStakes();
                        
                        console.log("Data refreshed after database save error - check if stake appears in list");
                    }

                    // Reset form and update UI
                    document.getElementById("stakeAmount").value = "";
                    calculateRewards();
                    await fetchTokenBalance();
                    await loadUserStakes();

                    // Start/update staking challenges
                    console.log("About to start staking challenges...");
                    await startStakingChallenges();
                    console.log("Staking challenges call completed");
                } catch (error) {
                    console.error("Smart contract staking error:", error);

                    // Check for specific duplicate transaction errors
                    if (
                        error.message &&
                        (error.message.includes("already been processed") || 
                         error.message.includes("This transaction has already been processed"))
                    ) {
                        console.log("Duplicate transaction detected - checking if stake was already recorded");

                        // Just refresh data to see if stake was actually created
                        showNotification(
                            "Transaction may have already been processed. Refreshing data...",
                            "info",
                        );
                        
                        await fetchTokenBalance();
                        await loadUserStakes();
                        
                        // Don't trigger recovery automatically - let user check if stake appears
                        console.log("Data refreshed - please check if your stake was recorded");
                        return;
                    }

                    let errorMessage = "Smart contract staking failed. ";
                    let showNetworkGuide = false;

                    if (
                        error.message &&
                        error.message.toLowerCase().includes("network")
                    ) {
                        errorMessage =
                            "Network Configuration Required: Please switch your wallet to Solana Devnet";
                        showNetworkGuide = true;
                    } else if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Transaction was cancelled by user.";
                    } else if (
                        error.message &&
                        error.message.includes("Insufficient")
                    ) {
                        errorMessage += "Insufficient funds for transaction.";
                    } else if (
                        error.message &&
                        error.message.includes(
                            "Transaction verification failed",
                        )
                    ) {
                        errorMessage += "Blockchain verification failed.";
                    } else {
                        errorMessage += error.message || "Please try again.";
                    }

                    showNotification(errorMessage, "error");

                    if (showNetworkGuide) {
                        setTimeout(() => showNetworkConfigurationModal(), 1000);
                    }
                } finally {
                    // Reset button state and staking flag
                    isStaking = false;
                    stakeBtn.innerHTML = "Stake Tokens";
                    stakeBtn.disabled = false;
                }
            }

            function showNetworkConfigurationModal() {
                const modal = document.createElement("div");
                modal.className =
                    "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4";
                modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full">
                    <div class="flex items-center mb-4">
                        <div class="w-8 h-8 bg-orange-100 rounded-full flex items-center justify-center mr-3">
                            <span class="text-orange-600">üåê</span>
                        </div>
                        <h3 class="text-lg font-semibold text-gray-900">Switch to Devnet</h3>
                    </div>
                    
                    <div class="mb-6">
                        <p class="text-sm text-gray-600 mb-4">
                            This platform requires <strong>Solana Devnet</strong>. Please configure your wallet:
                        </p>
                        
                        <div class="space-y-3">
                            <div class="p-3 bg-blue-50 rounded-lg">
                                <div class="font-semibold text-blue-900 text-sm mb-1">Phantom Wallet:</div>
                                <div class="text-xs text-blue-700">Settings ‚Üí Developer Settings ‚Üí Change Network ‚Üí Devnet</div>
                            </div>
                            
                            <div class="p-3 bg-purple-50 rounded-lg">
                                <div class="font-semibold text-purple-900 text-sm mb-1">Solflare Wallet:</div>
                                <div class="text-xs text-purple-700">Settings ‚Üí Network ‚Üí Switch to Devnet</div>
                            </div>
                        </div>
                        
                        <p class="text-xs text-gray-500 mt-4">
                            After switching networks, refresh this page and reconnect your wallet.
                        </p>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="flex-1 bg-gray-200 text-gray-800 px-4 py-2 rounded-lg text-sm hover:bg-gray-300">
                            Close
                        </button>
                        <button onclick="window.location.reload()" 
                                class="flex-1 bg-blue-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-blue-700">
                            Refresh Page
                        </button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Pagination variables
            let currentPage = 1;
            const recordsPerPage = 8;

            async function exportStakingRecords() {
                if (!walletConnected || !walletAddress) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                try {
                    showNotification("Exporting staking records...", "info");

                    const response = await fetch(
                        `/api/dapp/stakes/export/${walletAddress}?page=${currentPage}&limit=${recordsPerPage}`,
                    );

                    if (!response.ok) {
                        throw new Error("Failed to export records");
                    }

                    const data = await response.json();

                    if (data.success && data.csvData) {
                        // Create and download CSV file
                        const blob = new Blob([data.csvData], {
                            type: "text/csv",
                        });
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement("a");
                        link.href = url;
                        link.download =
                            data.filename ||
                            `staking_records_page${currentPage}.csv`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(url);

                        showNotification(
                            `Exported ${data.stakes.length} records (Page ${data.page}/${data.totalPages})`,
                            "success",
                        );

                        // Update pagination controls
                        updatePaginationControls(
                            data.page,
                            data.totalPages,
                            data.total,
                        );
                    } else {
                        showNotification(
                            data.message || "No records to export",
                            "warning",
                        );
                    }
                } catch (error) {
                    console.error("Error exporting staking records:", error);
                    showNotification(
                        "Failed to export staking records",
                        "error",
                    );
                }
            }

            function updatePaginationControls(page, totalPages, totalRecords) {
                const exportBtn = document.getElementById("exportCSV");
                const existingControls =
                    document.getElementById("paginationControls");

                if (existingControls) {
                    existingControls.remove();
                }

                if (totalPages > 1) {
                    const paginationDiv = document.createElement("div");
                    paginationDiv.id = "paginationControls";
                    paginationDiv.className =
                        "flex items-center space-x-2 text-sm text-gray-600";
                    paginationDiv.innerHTML = `
                        <span>Page ${page} of ${totalPages} (${totalRecords} total records)</span>
                        <button onclick="changePage(${page - 1})" 
                                ${page <= 1 ? "disabled" : ""} 
                                class="px-2 py-1 bg-gray-200 rounded text-xs hover:bg-gray-300 disabled:opacity-50">
                            Previous
                        </button>
                        <button onclick="changePage(${page + 1})" 
                                ${page >= totalPages ? "disabled" : ""} 
                                class="px-2 py-1 bg-gray-200 rounded text-xs hover:bg-gray-300 disabled:opacity-50">
                            Next
                        </button>
                    `;
                    exportBtn.parentNode.appendChild(paginationDiv);
                }
            }

            function changePage(newPage) {
                if (newPage >= 1) {
                    currentPage = newPage;
                    exportStakingRecords();
                }
            }

            async function claimRewards() {
                if (!walletConnected) {
                    alert("Please connect your wallet first");
                    return;
                }

                try {
                    const response = await fetch("/api/claim-rewards", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({ walletAddress }),
                    });

                    if (response.ok) {
                        const result = await response.json();
                        alert(
                            `Rewards claimed successfully! ${result.totalClaimed} SHSY will appear in your wallet shortly.`,
                        );
                        await loadUserStakes();
                    } else {
                        const error = await response.json();
                        alert("Failed to claim rewards: " + error.error);
                    }
                } catch (error) {
                    console.error("Error claiming rewards:", error);
                    alert("Failed to claim rewards. Please try again.");
                }
            }

            async function withdrawStake(stakeId, stakeAmount) {
                // Prevent multiple simultaneous calls
                if (isWithdrawing) {
                    console.log(
                        "Withdrawal already in progress, ignoring duplicate call",
                    );
                    return;
                }

                if (!walletConnected) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                console.log(
                    `Starting simplified withdrawal for stake ${stakeId} with amount ${stakeAmount}`,
                );

                // Set flag to prevent multiple calls
                isWithdrawing = true;

                try {
                    showNotification(
                        "Creating withdrawal transaction...",
                        "info",
                    );

                    // Create withdrawal transaction using smart contract
                    const response = await fetch("/api/dapp/withdraw", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            walletAddress,
                            id: stakeId, // Backend still uses stakeIndex for finding stake
                            amount: stakeAmount,
                        }),
                    });

                    if (!response.ok) {
                        const error = await response.json();

                        // Handle migration requirement for security upgrade
                        if (
                            error.error === "MIGRATION_REQUIRED" ||
                            error.requiresSync
                        ) {
                            showNotification(
                                `Security Migration Required: Your stakes need to be synced with the new secure contract. Total: ${error.totalStaked} SHSY across ${error.activeStakesCount} stakes.`,
                                "warning",
                            );

                            // Create sync button
                            if (
                                confirm(
                                    "Your stakes need to be synced with our new secure smart contract. This is a one-time security upgrade. Click OK to sync now.",
                                )
                            ) {
                                await syncUserStakes(
                                    error.totalStaked,
                                    error.activeStakesCount,
                                );
                            }
                            return;
                        }

                        showNotification(
                            "Failed to create withdrawal transaction: " +
                                error.error,
                            "error",
                        );
                        return;
                    }

                    const result = await response.json();

                    // Check if PDA distribution was completed automatically
                    if (result.completed) {
                        console.log(
                            "Stake withdrawal completed automatically via PDA:",
                            result.transactionSignature,
                        );

                        showNotification(
                            `Withdrawal completed! ${result.totalAmount} SHSY (${result.principal} principal + ${result.rewards} rewards) sent to your wallet automatically.`,
                            "success",
                        );

                        // Refresh displays immediately
                        await loadUserStakes();
                        if (window.loadBlockchainData) {
                            await loadBlockchainData();
                        }
                        return; // Exit early - no wallet signing needed
                    }

                    // Fallback to old wallet signing method (should not happen with PDA system)
                    console.log(
                        "Smart contract withdrawal transaction created:",
                        result.transactionData.instructions,
                    );

                    // Ensure we're using devnet connection
                    const devnetConnection = new window.solanaWeb3.Connection(
                        "https://api.devnet.solana.com",
                        "confirmed",
                    );

                    // Convert base64 transaction to Uint8Array
                    const serializedTransaction = Buffer.from(
                        result.transactionData.serializedTransaction,
                        "base64",
                    );
                    const transaction = window.solanaWeb3.Transaction.from(
                        serializedTransaction,
                    );

                    // Get fresh devnet blockhash to ensure proper network
                    const { blockhash, lastValidBlockHeight } =
                        await devnetConnection.getLatestBlockhash("confirmed");
                    transaction.recentBlockhash = blockhash;
                    transaction.lastValidBlockHeight = lastValidBlockHeight;

                    console.log(
                        "Updated transaction with devnet blockhash:",
                        blockhash,
                    );

                    // Sign and send transaction using wallet
                    const signedTransaction =
                        await window.solana.signTransaction(transaction);
                    console.log("Transaction signed by wallet");

                    // Send the signed transaction using devnet connection
                    const signature = await devnetConnection.sendRawTransaction(
                        signedTransaction.serialize(),
                    );
                    console.log("Withdrawal transaction sent:", signature);

                    showNotification(
                        "Withdrawal transaction submitted! Confirming...",
                        "info",
                    );

                    // Confirm the transaction using devnet connection
                    await devnetConnection.confirmTransaction(
                        signature,
                        "confirmed",
                    );
                    console.log("Withdrawal transaction confirmed:", signature);

                    // Automatic verification on successful withdrawal
                    console.log(
                        "Automatically verifying withdrawal and updating database...",
                    );

                    // Complete withdrawal using the same endpoint with signature
                    try {
                        const completionResponse = await fetch(
                            "/api/dapp/withdraw",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                    signature: signature,
                                    walletAddress,
                                    id: stakeId, // Using stake ID for completion
                                }),
                            },
                        );

                        if (completionResponse.ok) {
                            const completionResult =
                                await completionResponse.json();
                            console.log(
                                "Withdrawal completion successful:",
                                completionResult,
                            );
                        } else {
                            console.log(
                                "Withdrawal completion failed, but transaction was successful",
                            );
                        }
                    } catch (completionError) {
                        console.log(
                            "Completion error, but withdrawal was successful:",
                            completionError,
                        );
                    }

                    showNotification(
                        "Withdrawal successful! Tokens and rewards have been claimed.",
                        "success",
                    );
                    console.log("Withdrawal confirmed, refreshing all data...");

                    // Force refresh all UI components
                    await loadUserStakes();
                    await fetchTokenBalance();
                    await loadBlockchainData();
                    await loadDashboardStats();
                    await loadStakingChallenges(); // Reload challenges to show proper status

                    // Force re-render of stakes section
                    setTimeout(() => {
                        loadUserStakes();
                        loadStakingChallenges(); // Also reload challenges after delay
                    }, 1000);
                    console.log("All data refreshed after withdrawal");
                } catch (error) {
                    console.error("Smart contract withdrawal error:", error);

                    // Check if this is a duplicate transaction error (happens after successful withdrawal)
                    if (
                        error.message &&
                        error.message.includes("already been processed")
                    ) {
                        console.log(
                            "Duplicate transaction error - withdrawal was successful, performing automatic cleanup",
                        );

                        // Automatic database cleanup for successful duplicate transactions
                        try {
                            const cleanupResponse = await fetch(
                                "/api/dapp/withdraw",
                                {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json",
                                    },
                                    body: JSON.stringify({
                                        signature:
                                            "duplicate_transaction_cleanup",
                                        walletAddress,
                                        id: stakeId,
                                    }),
                                },
                            );

                            if (cleanupResponse.ok) {
                                const cleanupResult =
                                    await cleanupResponse.json();
                                console.log(
                                    "Automatic cleanup successful:",
                                    cleanupResult,
                                );
                            } else {
                                console.log(
                                    "Cleanup attempt failed, but withdrawal was successful",
                                );
                            }
                        } catch (cleanupError) {
                            console.log("Cleanup error:", cleanupError);
                        }

                        showNotification(
                            "Withdrawal completed successfully! Tokens have been returned to your wallet.",
                            "success",
                        );
                        console.log(
                            "Refreshing data after successful duplicate transaction...",
                        );
                        await loadUserStakes();
                        await fetchTokenBalance();
                        await loadBlockchainData();
                        await loadLeaderboard();
                        await loadDashboardStats();
                        await loadStakingChallenges(); // Reload challenges after cleanup
                        console.log(
                            "All data refreshed after automatic cleanup",
                        );
                        return;
                    }

                    let errorMessage = "Withdrawal failed: ";
                    if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Transaction was cancelled by user.";
                    } else if (
                        error.message &&
                        error.message.includes("Insufficient")
                    ) {
                        errorMessage +=
                            "Insufficient SOL for transaction fees.";
                    } else {
                        errorMessage += error.message || "Please try again.";
                    }

                    showNotification(errorMessage, "error");
                } finally {
                    // Reset withdrawal flag
                    isWithdrawing = false;
                }
            }

            // Notification system
            function showNotification(message, type = "info") {
                const notification = document.createElement("div");
                notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm ${
                    type === "success"
                        ? "bg-green-100 text-green-800 border border-green-200"
                        : type === "error"
                          ? "bg-red-100 text-red-800 border border-red-200"
                          : type === "warning"
                            ? "bg-yellow-100 text-yellow-800 border border-yellow-200"
                            : "bg-blue-100 text-blue-800 border border-blue-200"
                }`;

                notification.innerHTML = `
                <div class="flex items-center justify-between">
                    <span class="text-sm font-medium">${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-gray-400 hover:text-gray-600">√ó</button>
                </div>
            `;

                document.body.appendChild(notification);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            }

            async function syncUserStakes(totalStaked, activeStakesCount) {
                try {
                    showNotification(
                        "Creating stake sync transaction...",
                        "info",
                    );

                    // Request sync transaction from backend
                    const response = await fetch("/api/sync-user-stakes", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            walletAddress: walletAddress,
                        }),
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        showNotification(
                            "Sync failed: " + error.error,
                            "error",
                        );
                        return;
                    }

                    const result = await response.json();

                    if (!result.success || !result.transaction) {
                        showNotification(
                            result.message || "No sync needed",
                            "info",
                        );
                        return;
                    }

                    console.log("Sync transaction created:", result);

                    // Use devnet connection for sync
                    const devnetConnection = new window.solanaWeb3.Connection(
                        "https://api.devnet.solana.com",
                        "confirmed",
                    );

                    // Convert base64 transaction to Uint8Array
                    const serializedTransaction = Buffer.from(
                        result.transaction,
                        "base64",
                    );
                    const transaction = window.solanaWeb3.Transaction.from(
                        serializedTransaction,
                    );

                    // Get fresh devnet blockhash
                    const { blockhash, lastValidBlockHeight } =
                        await devnetConnection.getLatestBlockhash("confirmed");
                    transaction.recentBlockhash = blockhash;
                    transaction.lastValidBlockHeight = lastValidBlockHeight;

                    // Sign and send transaction using wallet
                    const signedTransaction =
                        await window.solana.signTransaction(transaction);

                    // Send the signed transaction
                    const signature = await devnetConnection.sendRawTransaction(
                        signedTransaction.serialize(),
                    );
                    console.log("Sync transaction sent:", signature);

                    showNotification(
                        "Sync transaction submitted! Confirming...",
                        "info",
                    );

                    // Confirm the transaction
                    await devnetConnection.confirmTransaction(
                        signature,
                        "confirmed",
                    );

                    showNotification(
                        "‚úÖ Stake sync completed! You can now withdraw your stakes.",
                        "success",
                    );
                    console.log("Sync transaction confirmed:", signature);

                    // Refresh data
                    await loadUserStakes();
                    await fetchTokenBalance();
                } catch (error) {
                    console.error("Sync error:", error);
                    let errorMessage = "Sync failed: ";
                    if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Transaction was cancelled by user.";
                    } else {
                        errorMessage += error.message || "Please try again.";
                    }
                    showNotification(errorMessage, "error");
                }
            }

            async function requestAirdrop() {
                if (!walletConnected || !walletAddress) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                try {
                    showNotification("Requesting test tokens...", "info");

                    const response = await fetch("/api/dapp/airdrop", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            walletAddress,
                        }),
                    });

                    const data = await response.json();

                    if (data.success) {
                        showNotification(data.message, "success");
                        fetchTokenBalance();
                    } else {
                        showNotification(
                            "Airdrop failed: " + data.error,
                            "error",
                        );
                    }
                } catch (error) {
                    console.error("Airdrop error:", error);
                    showNotification("Airdrop failed", "error");
                }
            }

            // Event listeners
            document.getElementById("connectWallet").onclick = showWalletModal;
            document.getElementById("connectPhantom").onclick = () =>
                connectWallet("phantom");
            document.getElementById("connectSolflare").onclick = () =>
                connectWallet("solflare");
            document.getElementById("airdropTokens").onclick = requestAirdrop;
            document.getElementById("stakeAmount").oninput = function() {
                calculateRewards();
                
                // [M-01 FIX] Real-time validation for stake amount
                const amount = parseFloat(this.value) || 0;
                const currentTotalStaked = window.userTotalStaked || 0;
                const maxStakePerUser = 1000000;
                const remainingCapacity = maxStakePerUser - currentTotalStaked;
                
                if (amount > remainingCapacity) {
                    this.style.borderColor = '#ef4444';
                    this.style.backgroundColor = '#fef2f2';
                } else {
                    this.style.borderColor = '#d1d5db';
                    this.style.backgroundColor = 'white';
                }
            };
            document.getElementById("lockPeriod").onchange = calculateRewards;
            document.getElementById("stakeBtn").onclick = stakeTokens;
            document.getElementById("exportCSV").onclick = exportStakingRecords;
            document.getElementById("refreshLeaderboard").onclick =
                loadLeaderboard;

            // Load leaderboard data
            async function loadLeaderboard() {
                try {
                    // Check if leaderboard elements exist on this page
                    const leaderboardGrid = document.getElementById("leaderboardGrid");
                    if (!leaderboardGrid) {
                        console.log("Leaderboard not available on this page");
                        return;
                    }

                    const response = await fetch("/api/leaderboard");
                    const data = await response.json();

                    if (data.success && data.leaderboard.length > 0) {
                        leaderboardGrid.innerHTML = "";

                        // Show top 6 stakers
                        const topStakers = data.leaderboard.slice(0, 6);
                        const medals = ["ü•á", "ü•à", "ü•â", "üèÖ", "üèÖ", "üèÖ"];

                        topStakers.forEach((user, index) => {
                            const truncatedWallet =
                                user.walletAddress.substring(0, 4) +
                                "..." +
                                user.walletAddress.substring(
                                    user.walletAddress.length - 4,
                                );
                            const medal = medals[index] || "üèÖ";

                            const leaderboardCard =
                                document.createElement("div");
                            leaderboardCard.className =
                                "border rounded-lg p-4 text-center transition-all duration-300 hover:shadow-lg";
                            leaderboardCard.style.background =
                                index < 3
                                    ? "linear-gradient(135deg, #fef3c7, #fde68a)"
                                    : "white";
                            leaderboardCard.innerHTML = `
                                <div class="text-2xl mb-2">${medal}</div>
                                <div class="font-bold text-lg">#${user.rank}</div>
                                <div class="text-sm text-gray-600 mb-2">${truncatedWallet}</div>
                                <div class="text-lg font-semibold text-green-600">${parseFloat(user.totalStaked).toLocaleString()} SHSY</div>
                                <div class="text-xs text-gray-500 mt-1">${user.activeStakes} active stakes</div>
                            `;
                            leaderboardGrid.appendChild(leaderboardCard);
                        });
                    } else {
                        const leaderboardGrid = document.getElementById("leaderboardGrid");
                        if (leaderboardGrid) {
                            leaderboardGrid.innerHTML = `
                                <div class="col-span-full border rounded-lg p-8 text-center">
                                    <div class="text-4xl mb-4">üèÜ</div>
                                    <div class="font-bold text-lg mb-2">No stakers yet!</div>
                                    <div class="text-gray-600">Be the first to stake and claim the top spot</div>
                                </div>
                            `;
                        }
                        const totalStakersInfoElement = document.getElementById("totalStakersInfo");
                        if (totalStakersInfoElement) {
                            totalStakersInfoElement.textContent =
                                "No active stakers yet. Start staking to appear on the leaderboard!";
                        }
                    }
                } catch (error) {
                    console.error("Error loading leaderboard:", error);
                    const leaderboardGrid = document.getElementById("leaderboardGrid");
                    if (leaderboardGrid) {
                        leaderboardGrid.innerHTML = `
                            <div class="col-span-full border rounded-lg p-8 text-center">
                                <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                                <div class="font-bold text-lg mb-2">Error loading leaderboard</div>
                                <div class="text-gray-600">Please try refreshing the page</div>
                            </div>
                        `;
                    }
                    const totalStakersInfoElement = document.getElementById("totalStakersInfo");
                    if (totalStakersInfoElement) {
                        totalStakersInfoElement.textContent = "Error loading staker statistics";
                    }
                }
            }

            async function loadDashboardStats() {
                try {
                    console.log("Loading dashboard stats...");

                    // Get stats for footer
                    const statsResponse = await apiRequest("/api/dapp/stats");
                    console.log("Stats response status:", statsResponse.status);

                    if (!statsResponse.ok) {
                        throw new Error(
                            `Stats API failed: ${statsResponse.status}`,
                        );
                    }

                    const statsData = await statsResponse.json();
                    console.log("Stats data received:", statsData);

                    if (statsData.success && statsData.stats) {
                        // Update total staked display with actual staked amount
                        const totalStakedElement =
                            document.getElementById("totalStaked");
                        if (totalStakedElement) {
                            totalStakedElement.textContent =
                                parseFloat(
                                    statsData.stats.totalStaked || 0,
                                ).toLocaleString() + " SHSY";
                            console.log(
                                "Updated totalStaked:",
                                totalStakedElement.textContent,
                            );
                        }

                        // Update active users display with all users who have staked
                        const activeUsersElement =
                            document.getElementById("activeUsers");
                        if (activeUsersElement) {
                            activeUsersElement.textContent =
                                statsData.stats.totalUsers.toLocaleString();
                            console.log(
                                "Updated activeUsers:",
                                activeUsersElement.textContent,
                            );
                        }

                        // Update total stakers info in leaderboard section
                        const totalStakersElement =
                            document.getElementById("totalStakersInfo");
                        if (totalStakersElement) {
                            totalStakersElement.innerHTML = `
                                Total Stakers: <strong>${statsData.stats.totalUsers}</strong> | 
                                Total Staked: <strong>${parseFloat(statsData.stats.totalStaked || 0).toLocaleString()} SHSY</strong> |
                                Active Stakes: <strong>${statsData.stats.activeStakes || 0}</strong>
                            `;
                            console.log("Updated totalStakersInfo");
                        }
                    } else {
                        console.error("Stats data invalid:", statsData);
                    }
                } catch (error) {
                    console.error("Error loading dashboard stats:", error);
                    console.error("Error details:", error.message);
                    console.error("Stats response failed");
                    // Set fallback values
                    const totalStakedElement =
                        document.getElementById("totalStaked");
                    if (totalStakedElement) {
                        totalStakedElement.textContent = "0 SHSY";
                    }
                    const activeUsersElement =
                        document.getElementById("activeUsers");
                    if (activeUsersElement) {
                        activeUsersElement.textContent = "0";
                    }
                }
            }

            async function loadBlockchainData() {
                // Load dashboard stats for accurate data
                await loadDashboardStats();

                try {
                    // Update prize pool from market data if available
                    const marketResponse = await apiRequest(
                        "/api/market/overview",
                    );
                    const marketData = await marketResponse.json();

                    if (marketData.success && marketData.prizePool) {
                        const prizeElement =
                            document.getElementById("prizePool");
                        if (prizeElement) {
                            prizeElement.textContent =
                                "$" + marketData.prizePool.toLocaleString();
                        }
                    }
                } catch (error) {
                    console.error("Error loading market data:", error);
                }
            }

            // Load smart contract program ID
            async function loadProgramInfo() {
                try {
                    const response = await apiRequest("/api/dapp/program-info");
                    const data = await response.json();

                    const programIdElement =
                        document.getElementById("programId");
                    if (programIdElement) {
                        if (response.ok && data.success && data.programInfo) {
                            programIdElement.textContent =
                                data.programInfo.programId;
                        } else {
                            programIdElement.textContent =
                                "Contract loading...";
                        }
                    }
                } catch (error) {
                    console.error("Error loading program info:", error);
                    const programIdElement =
                        document.getElementById("programId");
                    if (programIdElement) {
                        programIdElement.textContent = "Contract loading...";
                    }
                }
            }

            // Global variable to store pool data
            let stakingPools = [];

            // Load staking pools from API
            async function loadStakingPools() {
                try {
                    const response = await apiRequest("/api/dapp/pools");
                    const data = await response.json();

                    if (data.success && data.pools) {
                        stakingPools = data.pools;
                        populatePoolDropdown();
                        console.log("Pools loaded:", stakingPools);
                    } else {
                        console.error("Failed to load pools:", data.error);
                    }
                } catch (error) {
                    console.error("Error loading pools:", error);
                }
            }

            // Populate the lock period dropdown with pool data
            function populatePoolDropdown() {
                const lockPeriodSelect = document.getElementById("lockPeriod");
                lockPeriodSelect.innerHTML = "";

                stakingPools.forEach((pool) => {
                    const option = document.createElement("option");
                    option.value = pool.lockPeriod;
                    option.textContent = `${pool.lockPeriod} Days (${pool.apy}% APY)`;
                    lockPeriodSelect.appendChild(option);
                });
            }

            // Get pool info by lock period
            function getPoolByLockPeriod(lockPeriod) {
                return (
                    stakingPools.find(
                        (pool) => pool.lockPeriod == lockPeriod,
                    ) || { apy: 5, lockPeriod: 30, name: "Unknown Pool" }
                );
            }

            // Navigation System
            function showSection(section) {
                // Hide all sections
                const sections = [
                    "stakingSection",
                    "challengesSection",
                    "leaderboardSection",
                    "lockedFundsSection",
                ];
                sections.forEach((sectionId) => {
                    const element = document.getElementById(sectionId);
                    if (element) element.style.display = "none";
                });

                // Reset all tab styles
                const tabs = [
                    "stakingTab",
                    "challengesTab",
                    "lockedFundsTab",
                    "leaderboardTab",
                ];
                tabs.forEach((tabId) => {
                    const tab = document.getElementById(tabId);
                    if (tab) {
                        tab.style.backgroundColor = "";
                        tab.style.backgroundImage = ``;
                        tab.style.color = "#6b7280";
                    }
                });

                // Show selected section and highlight tab
                const sectionElement = document.getElementById(
                    section + "Section",
                );
                const tabElement = document.getElementById(section + "Tab");

                if (sectionElement && tabElement) {
                    sectionElement.style.display = "block";
                    tabElement.style.backgroundColor = "";
                    tabElement.style.backgroundImage = `linear-gradient(135deg, #00ddeb, #046bd2)`;
                    tabElement.style.color = "white";

                    // Load section-specific data
                    if (section === "challenges") {
                        loadStakingChallenges();
                    } else if (section === "lockedFunds") {
                        loadLockedFunds();
                    } else if (section === "leaderboard") {
                        loadLeaderboard();
                    }
                }
            }

            // Locked Funds Management (using existing variables)

            async function loadLockedFunds() {
                if (!walletConnected || !walletAddress) {
                    console.log("Wallet not connected for locked funds");
                    return;
                }

                try {
                    const response = await fetch(
                        `/api/dapp/locked-funds/${walletAddress}`,
                    );
                    const data = await response.json();

                    if (data.success) {
                        lockedFunds = data.lockedFunds;
                        lockedFundsSummary = data.summary;
                        updateLockedFundsUI();
                    } else {
                        console.error(
                            "Failed to load locked funds:",
                            data.error,
                        );
                    }
                } catch (error) {
                    console.error("Error loading locked funds:", error);
                }
            }

            function updateLockedFundsUI() {
                // Update summary cards
                const totalLockedElement =
                    document.getElementById("totalLockedAmount");
                const totalUnlockableElement = document.getElementById(
                    "totalUnlockableAmount",
                );
                const totalCountElement =
                    document.getElementById("totalLockedCount");

                if (totalLockedElement) {
                    totalLockedElement.textContent = `${parseFloat(lockedFundsSummary.totalLocked).toFixed(2)} SHSY`;
                }
                if (totalUnlockableElement) {
                    totalUnlockableElement.textContent = `${parseFloat(lockedFundsSummary.totalUnlockable).toFixed(2)} SHSY`;
                }
                if (totalCountElement) {
                    totalCountElement.textContent =
                        lockedFundsSummary.totalCount;
                }

                // Update locked funds list
                const listContainer =
                    document.getElementById("lockedFundsList");
                if (!listContainer) return;

                if (lockedFunds.length === 0) {
                    listContainer.innerHTML = `
                        <div class="border rounded-lg p-4 text-center text-gray-500">
                            <div class="text-lg mb-2">üîç</div>
                            <div>No locked funds found</div>
                            <div class="text-sm">Locked portions of your rewards will appear here</div>
                        </div>
                    `;
                    return;
                }

                listContainer.innerHTML = lockedFunds
                    .map((fund) => {
                        const unlockDate = new Date(fund.unlocksAt);
                        const now = new Date();
                        const isUnlockable =
                            now >= unlockDate && fund.status === "locked";
                        const daysUntilUnlock = Math.ceil(
                            (unlockDate - now) / (1000 * 60 * 60 * 24),
                        );

                        const rewardTypeLabel =
                            {
                                "10_day": "10-Day Challenge",
                                "30_day": "30-Day Challenge",
                                riddle: "Riddle Reward",
                                million_pool: "Million Pool",
                            }[fund.rewardType] || fund.rewardType;

                        // Determine token type - all rewards are now SHSY tokens
                        const tokenType = fund.tokenType || "SHSY";
                        const tokenSymbol = tokenType === "USDT" ? "$" : "";
                        const decimals = tokenType === "USDT" ? 2 : 8;

                        return `
                        <div class="border rounded-lg p-4 ${isUnlockable ? "border-green-300 bg-green-50" : fund.status === "withdrawn" ? "border-gray-300 bg-gray-50" : "border-blue-300 bg-blue-50"}">
                            <div class="flex justify-between items-start mb-3">
                                <div>
                                    <div class="font-semibold text-lg">${rewardTypeLabel}</div>
                                    <div class="text-sm text-gray-600">Locked ${fund.lockPercentage}% of ${tokenSymbol}${parseFloat(fund.totalRewardAmount).toFixed(decimals)} ${tokenType}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-xl font-bold ${isUnlockable ? "text-green-600" : fund.status === "withdrawn" ? "text-gray-600" : "text-blue-600"}">
                                        ${tokenSymbol}${parseFloat(fund.lockedAmount).toFixed(decimals)} ${tokenType}
                                    </div>
                                    <div class="text-sm ${fund.status === "withdrawn" ? "text-gray-500" : isUnlockable ? "text-green-500" : "text-blue-500"}">
                                        ${fund.status === "withdrawn" ? "Withdrawn" : isUnlockable ? "Ready to unlock" : `${daysUntilUnlock} days left`}
                                    </div>
                                </div>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-4 text-sm mb-3">
                                <div>
                                    <span class="text-gray-600">Lock Period:</span>
                                    <span class="font-medium">${fund.lockDays} days</span>
                                </div>
                                <div>
                                    <span class="text-gray-600">Locked:</span>
                                    <span class="font-medium">${new Date(fund.lockedAt).toLocaleDateString()}</span>
                                </div>
                            </div>

                            ${
                                isUnlockable
                                    ? `
                                <button
                                    onclick="unlockFund(${fund.id})"
                                    class="w-full text-white px-4 py-2 rounded-lg font-medium transition-all duration-300"
                                    style="background: linear-gradient(135deg, #00c4b4, #00e5d0);"
                                    onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 4px 12px rgba(0, 196, 180, 0.3)';"
                                    onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';"
                                >
                                    üîì Unlock ${tokenSymbol}${parseFloat(fund.lockedAmount).toFixed(decimals)} ${tokenType}
                                </button>
                            `
                                    : fund.status === "withdrawn"
                                      ? `
                                <div class="w-full text-center py-2 text-gray-500 border border-gray-300 rounded-lg">
                                    ‚úÖ Already withdrawn
                                </div>
                            `
                                      : `
                                <div class="w-full text-center py-2 text-blue-600 border border-blue-300 rounded-lg">
                                    üîí Unlocks on ${unlockDate.toLocaleDateString()}
                                </div>
                            `
                            }
                        </div>
                    `;
                    })
                    .join("");
            }

            async function unlockFund(lockedFundId) {
                if (!walletConnected || !walletAddress) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                try {
                    showNotification(
                        "Processing locked fund withdrawal...",
                        "info",
                    );

                    const response = await fetch("/api/locked-funds/withdraw", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            lockedFundId,
                            walletAddress,
                        }),
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Check if PDA distribution was completed automatically
                        if (data.completed) {
                            console.log(
                                "Locked fund withdrawal completed automatically via PDA:",
                                data.transactionSignature,
                            );

                            showNotification(
                                `${data.message} Amount: ${data.amount} SHSY`,
                                "success",
                            );

                            // Force refresh displays immediately after PDA withdrawal
                            setTimeout(async () => {
                                await loadLockedFunds();
                                console.log(
                                    "Locked funds refreshed after PDA withdrawal",
                                );
                                // Also refresh million pool claims in case they were affected
                                if (
                                    typeof loadMillionPoolWinnings ===
                                    "function"
                                ) {
                                    await loadMillionPoolWinnings();
                                }
                            }, 500);

                            // Additional fallback refresh to ensure UI updates
                            setTimeout(async () => {
                                await loadLockedFunds();
                                console.log(
                                    "Secondary locked funds refresh completed",
                                );
                            }, 2000);
                            return; // Exit early - no wallet signing needed
                        }

                        // Fallback to old wallet signing method (should not happen with PDA system)
                        if (data.transactionData) {
                            // Send transaction through wallet
                            const transaction = solanaWeb3.Transaction.from(
                                Buffer.from(
                                    data.transactionData.serializedTransaction,
                                    "base64",
                                ),
                            );

                            let signatureResult;
                            if (
                                window.solflare &&
                                window.solflare.isConnected
                            ) {
                                signatureResult =
                                    await window.solflare.signAndSendTransaction(
                                        transaction,
                                    );
                            } else if (
                                window.solana &&
                                window.solana.isConnected
                            ) {
                                signatureResult =
                                    await window.solana.signAndSendTransaction(
                                        transaction,
                                    );
                            }

                            // Extract signature string from result object
                            let signature;
                            console.log(
                                "Wallet signature result:",
                                signatureResult,
                            );
                            if (signatureResult) {
                                if (typeof signatureResult === "string") {
                                    signature = signatureResult;
                                } else if (signatureResult.signature) {
                                    signature = signatureResult.signature;
                                } else if (signatureResult.publicKey) {
                                    // Some wallets return {signature: string, publicKey: string}
                                    signature =
                                        signatureResult.signature ||
                                        signatureResult;
                                }
                            }
                            console.log("Extracted signature:", signature);

                            if (signature) {
                                console.log(
                                    `Unlock transaction sent: ${signature}`,
                                );

                                // Verify the unlock transaction
                                const verifyResponse = await fetch(
                                    "/api/dapp/locked-funds/verify-unlock",
                                    {
                                        method: "POST",
                                        headers: {
                                            "Content-Type": "application/json",
                                        },
                                        body: JSON.stringify({
                                            signature,
                                            lockedFundId,
                                        }),
                                    },
                                );

                                const verifyData = await verifyResponse.json();
                                if (verifyData.success) {
                                    const tokenDisplay =
                                        data.tokenType === "USDT"
                                            ? `$${parseFloat(data.rewardAmount).toFixed(2)} USDT`
                                            : `${parseFloat(data.rewardAmount).toFixed(8)} SHSY`;
                                    showNotification(
                                        `Successfully unlocked ${tokenDisplay}!`,
                                        "success",
                                    );
                                    loadLockedFunds(); // Refresh the list
                                    loadTokenBalance(); // Update token balance
                                } else {
                                    console.error(
                                        "Unlock verification failed:",
                                        verifyData.error,
                                    );
                                }
                            } else {
                                showNotification(
                                    "Transaction signature not found",
                                    "error",
                                );
                            }
                        } else {
                            showNotification(
                                "Transaction data not provided for fallback method",
                                "error",
                            );
                        }
                    } else {
                        showNotification(
                            `Failed to withdraw locked fund: ${data.error || "Unknown error"}`,
                            "error",
                        );
                    }
                } catch (error) {
                    console.error("Error unlocking fund:", error);
                    showNotification(
                        "Error unlocking fund. Please try again.",
                        "error",
                    );
                }
            }

            // Million Pool functionality
            let millionPoolSettings = null;

            // Load million pool winnings for connected wallet
            // async function loadMillionPoolWinnings() {
            //     try {
            //         if (!currentWallet) {
            //             console.log(
            //                 "No wallet connected, skipping million pool winnings load",
            //             );
            //             return;
            //         }

            //         console.log(
            //             "Loading million pool winnings for wallet:",
            //             currentWallet,
            //         );
            //         const response = await fetch(
            //             `/api/million-pool/winners/${currentWallet}`,
            //         );
            //         const data = await response.json();
            //         console.log("Million pool winnings response:", data);

            //         if (data.success && data.winners.length > 0) {
            //             console.log(
            //                 "Displaying million pool winnings:",
            //                 data.winners,
            //             );
            //             displayMillionPoolWinnings(data.winners);
            //         } else {
            //             console.log(
            //                 "No million pool winnings found for this wallet",
            //             );
            //         }
            //     } catch (error) {
            //         console.error(
            //             "Failed to load million pool winnings:",
            //             error,
            //         );
            //     }
            // }

            // Display million pool winnings with claim buttons
            function displayMillionPoolWinnings(winners) {
                let html =
                    '<div class="mt-4"><h3 class="text-lg font-semibold mb-3 text-gray-900">üèÜ Your Million Pool Winnings</h3>';

                winners.forEach((winner) => {
                    const amount = parseFloat(winner.rewardAmountShsy);
                    const canClaim = winner.canClaim;
                    const status = winner.status;

                    html += `
                        <div class="border border-gray-200 rounded-lg p-4 mb-3" style="background: linear-gradient(135deg, #f0fdfa 0%, #ecfdf5 100%);">
                            <div class="flex justify-between items-center">
                                <div>
                                    <div class="font-semibold text-gray-900">Million Pool Prize</div>
                                    <div class="text-2xl font-bold text-green-600">${amount.toFixed(2)} SHSY</div>
                                    <div class="text-sm text-gray-500">Distribution #${winner.distributionId} ‚Ä¢ ${new Date(winner.createdAt).toLocaleDateString()}</div>
                                </div>
                                <div class="text-right">
                                    ${
                                        canClaim
                                            ? `
                                        <button 
                                            onclick="claimMillionPoolPrize(${winner.id})"
                                            class="px-4 py-2 rounded-lg font-medium text-white transition-all duration-300 transform hover:scale-105"
                                            style="background: linear-gradient(135deg, #00c4b4 0%, #00a399 100%);"
                                        >
                                            üí∞ Claim Prize
                                        </button>
                                    `
                                            : `
                                        <div class="px-4 py-2 rounded-lg bg-gray-100 text-gray-600 text-sm">
                                            Prize Claimed
                                        </div>
                                    `
                                    }
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += "</div>";

                // Add to million pool section
                const millionPoolSection =
                    document.getElementById("millionPoolSection");
                if (millionPoolSection) {
                    const existingWinnings = millionPoolSection.querySelector(
                        ".million-pool-winnings",
                    );
                    if (existingWinnings) {
                        existingWinnings.remove();
                    }

                    const winningsDiv = document.createElement("div");
                    winningsDiv.className = "million-pool-winnings";
                    winningsDiv.innerHTML = html;
                    millionPoolSection.appendChild(winningsDiv);
                }
            }

            // Claim million pool prize through fund locking system
            async function claimMillionPoolPrize(winnerId) {
                try {
                    if (!currentWallet) {
                        showNotification(
                            "Please connect your wallet first",
                            "error",
                        );
                        return;
                    }

                    const response = await fetch(
                        `/api/million-pool/claim/${winnerId}`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                walletAddress: currentWallet,
                            }),
                        },
                    );

                    const data = await response.json();

                    if (data.success) {
                        showNotification(
                            `Million pool prize claimed! Reward processed through fund locking system.`,
                            "success",
                        );

                        // Refresh winnings and locked funds
                        loadMillionPoolWinnings();
                        if (typeof loadLockedFunds === "function") {
                            loadLockedFunds();
                        }
                    } else {
                        showNotification(
                            `Failed to claim prize: ${data.error}`,
                            "error",
                        );
                    }
                } catch (error) {
                    console.error("Error claiming million pool prize:", error);
                    showNotification(
                        "Failed to claim million pool prize. Please try again.",
                        "error",
                    );
                }
            }

            // Load million pool settings and check visibility
            async function loadMillionPoolSettings() {
                try {
                    const response = await fetch(
                        "/api/admin/million-pool/settings",
                    );
                    const data = await response.json();

                    if (data.success && data.settings) {
                        millionPoolSettings = data.settings;
                        updateMillionPoolDisplay();
                    }
                } catch (error) {
                    console.error(
                        "Failed to load million pool settings:",
                        error,
                    );
                }
            }

            // Update million pool display based on settings and user eligibility
            async function updateMillionPoolDisplay() {
                const millionPoolSection =
                    document.getElementById("millionPoolSection");

                if (!millionPoolSettings || !millionPoolSettings.isActive) {
                    millionPoolSection.style.display = "none";
                    return;
                }

                millionPoolSection.style.display = "block";

                // Update requirements display
                document.getElementById("usdtRequirement").textContent =
                    `$${parseFloat(millionPoolSettings.usdtRequirement).toFixed(2)}`;
                document.getElementById("shsyRequirement").textContent =
                    `${parseFloat(millionPoolSettings.shsyRequirement)} SHSY`;
                document.getElementById("rewardPerWinner").textContent =
                    `${parseFloat(millionPoolSettings.rewardAmountShsy).toFixed(2)} SHSY`;
                document.getElementById("numberOfWinners").textContent =
                    millionPoolSettings.numberOfWinners;

                // Calculate next distribution time
                const nextDistTime = new Date(
                    Date.now() +
                        millionPoolSettings.distributionFrequencyMinutes *
                            60000,
                );
                document.getElementById("nextDistribution").textContent =
                    nextDistTime.toLocaleString();

                // Reset status to loading when no wallet connected
                if (typeof currentWallet === "undefined" || !currentWallet) {
                    document.getElementById("millionPoolStatus").textContent =
                        "Loading...";
                    document.getElementById(
                        "millionPoolConnectMessage",
                    ).style.display = "block";
                    document.getElementById("depositUSDTButton").style.display =
                        "none";
                    document.getElementById(
                        "autoQualifiedMessage",
                    ).style.display = "none";
                    document.getElementById(
                        "millionPoolParticipating",
                    ).style.display = "none";
                } else {
                    // Check eligibility if wallet is connected
                    await checkMillionPoolEligibility();
                    await loadUserBalances();
                    await loadMillionPoolWinnings();
                }
            }

            // Check if user is eligible for million pool
            async function checkMillionPoolEligibility() {
                if (
                    typeof currentWallet === "undefined" ||
                    !currentWallet ||
                    !millionPoolSettings
                )
                    return;

                try {
                    const response = await fetch(
                        `/api/million-pool/eligibility/${currentWallet}`,
                    );
                    const data = await response.json();

                    console.log("Million pool eligibility response:", data);

                    const statusElement =
                        document.getElementById("millionPoolStatus");
                    const depositButton =
                        document.getElementById("depositUSDTButton");
                    const autoQualifiedMessage = document.getElementById(
                        "autoQualifiedMessage",
                    );
                    const participatingMessage = document.getElementById(
                        "millionPoolParticipating",
                    );
                    const connectMessage = document.getElementById(
                        "millionPoolConnectMessage",
                    );

                    // Hide connect message since wallet is connected
                    connectMessage.style.display = "none";

                    if (data.success) {
                        if (data.isParticipating) {
                            statusElement.textContent = "Participating";
                            statusElement.style.backgroundColor = "#dcfce7";
                            statusElement.style.color = "#166534";
                            participatingMessage.style.display = "block";
                            depositButton.style.display = "none";
                            autoQualifiedMessage.style.display = "none";
                        } else if (data.autoQualified) {
                            statusElement.textContent = "Auto-Qualified";
                            statusElement.style.backgroundColor = "#e0f7fa";
                            statusElement.style.color = "#00695c";
                            autoQualifiedMessage.style.display = "block";
                            depositButton.style.display = "none";
                            participatingMessage.style.display = "none";
                        } else {
                            statusElement.textContent = "Eligible";
                            statusElement.style.backgroundColor = "#f3f4f6";
                            statusElement.style.color = "#6b7280";
                            depositButton.style.display = "block";
                            autoQualifiedMessage.style.display = "none";
                            participatingMessage.style.display = "none";
                        }
                    }
                } catch (error) {
                    console.error(
                        "Failed to check million pool eligibility:",
                        error,
                    );
                }
            }

            // Handle USDT deposit for million pool participation
            async function depositUSDT() {
                if (
                    typeof currentWallet === "undefined" ||
                    !currentWallet ||
                    !millionPoolSettings
                ) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                const depositButton =
                    document.getElementById("depositUSDTButton");
                const originalText = depositButton.textContent;

                try {
                    depositButton.textContent = "Processing...";
                    depositButton.disabled = true;

                    const depositAmount = parseFloat(
                        millionPoolSettings.usdtRequirement,
                    );

                    // Check USDT balance first
                    const balanceResponse = await fetch(
                        `/api/usdt-balance/${currentWallet}`,
                    );
                    const balanceData = await balanceResponse.json();

                    if (
                        balanceData.success &&
                        balanceData.balance < depositAmount
                    ) {
                        showNotification(
                            `Insufficient USDT balance. Required: $${depositAmount.toFixed(2)}, Available: $${balanceData.balance.toFixed(2)}`,
                            "error",
                        );
                        return;
                    }

                    // Create USDT deposit transaction
                    const response = await fetch(
                        "/api/million-pool/usdt-deposit",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                walletAddress: currentWallet,
                                depositAmount: depositAmount,
                            }),
                        },
                    );

                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(
                            data.error ||
                                "Failed to create USDT deposit transaction",
                        );
                    }

                    // Send transaction through wallet
                    console.log("API response data:", data);
                    console.log("Transaction string:", data.transaction);

                    // Check if wallet is connected and web3.js is loaded
                    if (!window.solana || !window.solana.isConnected) {
                        throw new Error("Wallet not connected");
                    }

                    if (
                        typeof solanaWeb3 === "undefined" ||
                        !solanaWeb3.Transaction
                    ) {
                        throw new Error("Solana web3.js not loaded");
                    }

                    // Convert base64 to buffer and create transaction
                    const transactionBuffer = Buffer.from(
                        data.transaction,
                        "base64",
                    );
                    const transaction =
                        solanaWeb3.Transaction.from(transactionBuffer);

                    depositButton.textContent = "Waiting for wallet...";

                    const signed =
                        await window.solana.signAndSendTransaction(transaction);
                    const signature = signed.signature;

                    depositButton.textContent = "Verifying...";

                    // Verify transaction and add to million pool
                    const verifyResponse = await fetch(
                        "/api/million-pool/verify-usdt",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                signature: signature,
                                walletAddress: currentWallet,
                                depositAmount: depositAmount,
                            }),
                        },
                    );

                    const verifyData = await verifyResponse.json();

                    if (verifyData.success) {
                        showNotification(
                            `Successfully deposited $${depositAmount.toFixed(2)} USDT! You're now participating in the Million SHSY Pool.`,
                            "success",
                        );

                        // Refresh million pool display
                        await updateMillionPoolDisplay();
                    } else {
                        throw new Error(
                            verifyData.error || "Failed to verify USDT deposit",
                        );
                    }
                } catch (error) {
                    console.error("USDT deposit failed:", error);

                    let errorMessage = "USDT deposit failed. ";

                    if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Transaction was cancelled by user.";
                    } else if (
                        error.message &&
                        error.message.includes("Insufficient")
                    ) {
                        errorMessage += "Insufficient USDT balance.";
                    } else {
                        errorMessage += error.message || "Please try again.";
                    }

                    showNotification(errorMessage, "error");
                } finally {
                    depositButton.textContent = originalText;
                    depositButton.disabled = false;
                }
            }

            // Load user balances for million pool display
            async function loadUserBalances() {
                if (typeof currentWallet === "undefined" || !currentWallet)
                    return;

                try {
                    // Load USDT balance
                    const usdtResponse = await fetch(
                        `/api/usdt-balance/${currentWallet}`,
                    );
                    const usdtData = await usdtResponse.json();

                    if (usdtData.success) {
                        document.getElementById("userUsdtBalance").textContent =
                            `Balance: $${usdtData.balance.toFixed(2)}`;
                    } else {
                        document.getElementById("userUsdtBalance").textContent =
                            "Balance: $0.00";
                    }

                    // Calculate total SHSY staked from user stakes
                    const stakesResponse = await fetch(
                        `/api/dapp/user-stakes/${currentWallet}`,
                    );
                    const stakesData = await stakesResponse.json();

                    if (stakesData.success && stakesData.stakes) {
                        const totalStaked = stakesData.stakes
                            .filter((stake) => stake.status !== "withdrawn")
                            .reduce(
                                (sum, stake) => sum + parseFloat(stake.amount),
                                0,
                            );

                        document.getElementById("userShsyStaked").textContent =
                            `Staked: ${totalStaked.toFixed(2)} SHSY`;
                    } else {
                        document.getElementById("userShsyStaked").textContent =
                            "Staked: 0.00 SHSY";
                    }
                } catch (error) {
                    console.error("Failed to load user balances:", error);
                    document.getElementById("userUsdtBalance").textContent =
                        "Balance: Error";
                    document.getElementById("userShsyStaked").textContent =
                        "Staked: Error";
                }
            }

            // Million Pool Winnings functionality
            async function loadMillionPoolWinnings() {
                if (!currentWallet) {
                    console.log(
                        "No wallet connected for million pool winnings",
                    );
                    return;
                }

                try {
                    console.log(
                        "Loading million pool winnings for wallet:",
                        currentWallet,
                    );
                    const response = await fetch(
                        `/api/million-pool/winners/${currentWallet}`,
                    );
                    const data = await response.json();
                    console.log("Million pool winnings response:", data);

                    if (data.success && data.winners) {
                        displayMillionPoolWinnings(data.winners);
                    } else {
                        console.log(
                            "No million pool winnings found for this wallet",
                        );
                        displayMillionPoolWinnings([]); // Hide claims section
                    }
                } catch (error) {
                    console.error(
                        "Failed to load million pool winnings:",
                        error,
                    );
                }
            }

            function displayMillionPoolWinnings(winners) {
                const claimsSection = document.getElementById(
                    "millionPoolClaimsSection",
                );
                const claimsList = document.getElementById(
                    "millionPoolClaimsList",
                );

                // Filter out claimed prizes - only show unclaimed winnings
                const unclaimedWinners = winners ? winners.filter(winner => 
                    winner.status !== 'claimed' && winner.canClaim
                ) : [];

                console.log(`Million pool winnings: ${winners?.length || 0} total, ${unclaimedWinners.length} unclaimed`);

                // Show claims inside million pool participation box if user has unclaimed winnings
                if (unclaimedWinners && unclaimedWinners.length > 0) {
                    claimsSection.style.display = "block";

                    // Clear existing claims
                    claimsList.innerHTML = "";

                    // Add each unclaimed winning record in compact format
                    unclaimedWinners.forEach((winner) => {
                        const winnerDiv = document.createElement("div");
                        winnerDiv.className =
                            "flex items-center justify-between p-2 bg-gray-50 rounded-lg";

                        const statusText =
                            winner.status === "pending"
                                ? "Available"
                                : winner.status === "claimed"
                                  ? "Claimed"
                                  : "Processing";

                        const actionButton = winner.canClaim
                            ? `<button onclick="claimMillionPoolPrize(${winner.id}, '${winner.rewardAmountShsy}')" 
                                     class="bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-600 hover:to-blue-700 text-white text-xs py-1 px-3 rounded-lg font-medium transition-colors">
                                üéÅ Claim ${parseFloat(winner.rewardAmountShsy).toFixed(2)} SHSY
                             </button>`
                            : `<span class="text-gray-500 text-xs">
                                ${winner.status === "claimed" ? "‚úì Claimed" : "Processing"}
                             </span>`;

                        winnerDiv.innerHTML = `
                            <div class="flex-1">
                                <div class="text-xs font-medium text-gray-900">${parseFloat(winner.rewardAmountShsy).toFixed(2)} SHSY Prize</div>
                                <div class="text-xs text-gray-600">${statusText} ‚Ä¢ ${new Date(winner.createdAt).toLocaleDateString()}</div>
                            </div>
                            <div class="ml-2">
                                ${actionButton}
                            </div>
                        `;

                        claimsList.appendChild(winnerDiv);
                    });
                } else {
                    // Hide claims section if no unclaimed winnings
                    claimsSection.style.display = "none";
                    console.log("No unclaimed million pool winnings - hiding claims section");
                }
            }

            async function claimMillionPoolPrize(winnerId, amount) {
                if (!currentWallet) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                const claimButton = event.target;
                const originalText = claimButton.textContent;

                // Prevent multiple rapid clicks
                if (claimButton.disabled) {
                    return;
                }

                try {
                    claimButton.textContent = "Creating Transaction...";
                    claimButton.disabled = true;

                    console.log(
                        `Claiming million pool prize ${winnerId} for ${amount} SHSY`,
                    );

                    // Step 1: Create USDT withdrawal transaction
                    const createResponse = await fetch(
                        "/api/million-pool/claim",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                winnerId: winnerId,
                                walletAddress: currentWallet,
                            }),
                        },
                    );

                    if (!createResponse.ok) {
                        const error = await createResponse.json();
                        throw new Error(
                            error.error ||
                                "Failed to create withdrawal transaction",
                        );
                    }

                    const createResult = await createResponse.json();

                    // Check if PDA distribution was completed automatically
                    if (createResult.completed) {
                        console.log(
                            "Million pool prize distributed automatically via PDA:",
                            createResult.transactionSignature,
                        );

                        // Show success message with detailed breakdown
                        const lockInfo =
                            createResult.lockedAmount > 0
                                ? ` ${createResult.lockedAmount} SHSY (${createResult.lockPercentage}%) is locked for ${createResult.lockDurationDays} days.`
                                : "";

                        showNotification(
                            `Successfully claimed ${amount} SHSY prize! ${createResult.availableAmount} SHSY sent to wallet automatically.${lockInfo}`,
                            "success",
                        );

                        // Refresh displays immediately
                        await loadMillionPoolWinnings();
                        if (window.loadLockedFunds) {
                            await loadLockedFunds();
                        }
                        return; // Exit early - no wallet signing needed
                    }

                    // Fallback to old wallet signing method (should not happen with PDA system)
                    const {
                        transactionData,
                        immediateAmount,
                        lockedAmount,
                        lockDurationDays,
                        lockPercentage,
                    } = createResult;

                    console.log(
                        "USDT withdrawal transaction created:",
                        transactionData,
                    );

                    claimButton.textContent = "Confirm in Wallet...";

                    // Step 2: Get wallet provider for signing
                    let provider;
                    if (window.connectedWalletProvider) {
                        provider = window.connectedWalletProvider;
                    } else if (window.solflare && window.solflare.isSolflare) {
                        provider = window.solflare;
                    } else if (window.solana && window.solana.isPhantom) {
                        provider = window.solana;
                    } else if (window.solana) {
                        provider = window.solana;
                    } else {
                        throw new Error(
                            "No wallet provider found. Please install Phantom or Solflare wallet.",
                        );
                    }

                    // Step 3: Sign and send transaction
                    const transactionBuffer = Uint8Array.from(
                        atob(transactionData.serializedTransaction),
                        (c) => c.charCodeAt(0),
                    );
                    const transaction = Transaction.from(transactionBuffer);

                    const signedTransaction =
                        await provider.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(
                        signedTransaction.serialize(),
                    );

                    console.log(
                        "SHSY withdrawal transaction signed and sent:",
                        signature,
                    );
                    claimButton.textContent = "Verifying...";

                    // Step 4: Verify transaction on backend
                    const verifyResponse = await fetch(
                        "/api/million-pool/verify-withdraw",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                signature: signature,
                                winnerId: winnerId,
                                walletAddress: currentWallet,
                            }),
                        },
                    );

                    if (!verifyResponse.ok) {
                        const error = await verifyResponse.json();
                        throw new Error(
                            error.error || "Failed to verify transaction",
                        );
                    }

                    console.log(
                        "Million pool prize claimed and verified successfully",
                    );

                    // Show success message with detailed breakdown
                    const lockInfo =
                        lockPercentage > 0
                            ? ` ${lockedAmount} SHSY (${lockPercentage}%) is locked for ${lockDurationDays} days.`
                            : "";

                    showNotification(
                        `Successfully claimed ${amount} SHSY prize! ${immediateAmount} SHSY sent to wallet instantly.${lockInfo}`,
                        "success",
                    );

                    // Refresh displays
                    await loadMillionPoolWinnings();
                    if (window.loadLockedFunds) {
                        await loadLockedFunds();
                    }
                } catch (error) {
                    console.error("Million pool claim failed:", error);

                    let errorMessage = "Million pool claim failed. ";

                    if (
                        error.message &&
                        error.message.includes("already claimed")
                    ) {
                        errorMessage += "Prize already claimed.";
                    } else if (
                        error.message &&
                        error.message.includes("User rejected")
                    ) {
                        errorMessage += "Transaction rejected by user.";
                    } else {
                        errorMessage += error.message || "Please try again.";
                    }

                    showNotification(errorMessage, "error");
                } finally {
                    claimButton.textContent = originalText;
                    claimButton.disabled = false;
                }
            }

            // Initialize
            updateWalletUI();
            calculateRewards();
            loadBlockchainData();
            loadProgramInfo();
            loadStakingPools();
            loadRewardSettings(); // Load reward settings from database
            loadMillionPoolSettings(); // Load million pool settings

            // Debug: Try to load million pool winnings for testing
            setTimeout(async () => {
                if (currentWallet) {
                    console.log(
                        "Debug: Loading million pool winnings for currentWallet:",
                        currentWallet,
                    );
                    await loadMillionPoolWinnings();
                } else {
                    console.log(
                        "Debug: No currentWallet set, checking for persistent wallet connection...",
                    );
                    // Try to restore wallet connection from localStorage or check for existing connection
                    if (window.solana && window.solana.publicKey) {
                        currentWallet = window.solana.publicKey.toString();
                        console.log(
                            "Debug: Found persistent wallet connection:",
                            currentWallet,
                        );
                        await loadMillionPoolWinnings();
                    }
                }
            }, 2000);

            // Debug function that can be called from browser console
            window.debugLoadMillionPoolWinnings = async function (
                walletAddress,
            ) {
                console.log(
                    "Debug: Manually loading million pool winnings for:",
                    walletAddress,
                );
                currentWallet =
                    walletAddress ||
                    "C73nuwe78M2N9f62YJDysZYwPX1TcRZjrsE1KSJHW8w2";
                await loadMillionPoolWinnings();
            };

            // Show staking section by default
            showSection("staking");

            // Force update footer stats immediately
            setTimeout(() => {
                loadDashboardStats();
            }, 1000);
            // Staking Challenges functionality
            let challengeTimers = {};
            let rewardSettings = {
                participation_10d: 75, // Default fallback
                participation_30d: 150, // Default fallback
            };

            // Load reward settings from database
            async function loadRewardSettings() {
                try {
                    const response = await apiRequest(
                        "/api/admin/reward-settings",
                    );
                    const data = await response.json();

                    if (data.success && data.settings) {
                        // Update rewardSettings object with database values
                        data.settings.forEach((setting) => {
                            if (setting.settingKey === "participation_10d") {
                                rewardSettings.participation_10d = parseFloat(
                                    setting.settingValue,
                                );
                            } else if (
                                setting.settingKey === "participation_30d"
                            ) {
                                rewardSettings.participation_30d = parseFloat(
                                    setting.settingValue,
                                );
                            }
                        });

                        console.log("Loaded reward settings:", rewardSettings);

                        // Update UI with database values
                        updateRewardDisplays();
                    }
                } catch (error) {
                    console.error("Error loading reward settings:", error);
                    // Keep using fallback values
                }
            }

            // Update reward displays in UI
            function updateRewardDisplays() {
                const challenge10Reward =
                    document.getElementById("challenge10Reward");
                const challenge30Reward =
                    document.getElementById("challenge30Reward");
                const claim10ButtonText =
                    document.getElementById("claim10ButtonText");
                const claim30ButtonText =
                    document.getElementById("claim30ButtonText");

                // Reward amounts will be loaded from API - remove hardcoded values
            }

            // Update pending rewards display
            function updatePendingRewardsDisplay() {
                // Add pending rewards section to each challenge card if rewards exist
                const pendingRewards10 = pendingRewards.filter(
                    (r) => r.challengeType === "10_day",
                );
                const pendingRewards30 = pendingRewards.filter(
                    (r) => r.challengeType === "30_day",
                );

                updatePendingRewardCard("10", pendingRewards10);
                updatePendingRewardCard("30", pendingRewards30);
            }

            // Update pending reward for specific challenge type
            function updatePendingRewardCard(type, rewards) {
                const claimBtn = document.getElementById(
                    `claim${type}DayReward`,
                );
                if (!claimBtn) return;

                if (rewards.length > 0) {
                    const reward = rewards[0]; // Show first pending reward
                    claimBtn.style.display = "block";
                    claimBtn.disabled = false;
                    claimBtn.addEventListener("click", () =>
                        claimChallengeReward(type + "_day"),
                    );
                    claimBtn.innerHTML = `üéâ Claim ${parseFloat(reward.rewardAmount).toFixed(0)} SHSY Winner Reward!`;
                    claimBtn.className =
                        "w-full gradient-btn text-white py-3 px-4 rounded-lg font-bold transition-all duration-300 animate-pulse shadow-lg";
                    claimBtn.addEventListener("mouseover", function () {
                        this.style.transform = "scale(1.02)";
                        this.style.boxShadow =
                            "0 8px 25px rgba(20, 184, 166, 0.4)";
                    });
                    claimBtn.addEventListener("mouseout", function () {
                        this.style.transform = "scale(1)";
                        this.style.boxShadow =
                            "0 4px 12px rgba(20, 184, 166, 0.3)";
                    });
                } else {
                    // No pending rewards - hide claim button or show regular state
                    claimBtn.style.display = "none";
                }
            }

            // Claim reward function
            async function claimChallengeReward(challengeType, type) {
                if (!walletConnected || !walletAddress) {
                    showNotification(
                        "Please connect your wallet first",
                        "error",
                    );
                    return;
                }

                try {
                    showNotification(
                        `Preparing ${type}-day challenge reward...`,
                        "info",
                    );

                    console.log(
                        "Making claim request to:",
                        "/api/dapp/challenges/claim",
                    );
                    console.log("Request payload:", {
                        challengeType,
                        walletAddress,
                    });

                    const response = await fetch(
                        window.location.origin + "/api/dapp/challenges/claim",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Cache-Control": "no-cache",
                                Pragma: "no-cache",
                            },
                            body: JSON.stringify({
                                challengeType: challengeType,
                                walletAddress: walletAddress,
                            }),
                        },
                    );

                    console.log("Response status:", response.status);
                    console.log("Response URL:", response.url);
                    console.log("Response headers:", response.headers);
                    const responseText = await response.text();
                    console.log("Raw response text:", responseText);

                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error("JSON parse error:", parseError);
                        showNotification("Invalid response format", "error");
                        return;
                    }
                    console.log("Claim API response:", data);

                    if (!data.success) {
                        showNotification(
                            data.error || "Failed to prepare reward claim",
                            "error",
                        );
                        return;
                    }

                    // Check if PDA distribution was completed automatically
                    if (data.completed) {
                        console.log(
                            "Challenge reward distributed automatically via PDA:",
                            data.transactionSignature,
                        );

                        showNotification(data.message, "success");
                        await loadStakingChallenges();
                        if (window.loadLockedFunds) {
                            await loadLockedFunds();
                        }
                        return; // Exit early - no wallet signing needed
                    }

                    // Handle case where all funds are locked
                    if (data.allLocked) {
                        showNotification(data.message, "info");
                        await loadStakingChallenges();
                        return;
                    }

                    if (!data.transaction) {
                        console.error("No transaction data in response:", data);
                        showNotification(
                            "Invalid reward transaction data",
                            "error",
                        );
                        return;
                    }

                    // Fallback to old wallet signing method (should not happen with PDA system)
                    console.log(
                        `Claiming ${type}-day challenge reward:`,
                        data.rewardAmount,
                        "SHSY",
                    );
                    console.log("Transaction data:", data);

                    const serializedTransaction = data.transaction;
                    const transactionBuffer = Uint8Array.from(
                        atob(serializedTransaction),
                        (c) => c.charCodeAt(0),
                    );
                    const transaction =
                        solanaWeb3.Transaction.from(transactionBuffer);

                    // Create connection for this transaction
                    const connection = new solanaWeb3.Connection(
                        "https://api.devnet.solana.com",
                        "confirmed",
                    );

                    // Get latest blockhash
                    const { blockhash } = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = new solanaWeb3.PublicKey(
                        walletAddress,
                    );

                    // Sign and send transaction
                    const signedTransaction =
                        await window.solana.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(
                        signedTransaction.serialize(),
                    );

                    console.log(
                        `${type}-day challenge reward transaction signed:`,
                        signature,
                    );

                    // Wait for transaction confirmation
                    console.log("Waiting for transaction confirmation...");
                    await connection.confirmTransaction(signature, "confirmed");

                    console.log(
                        `Challenge reward transaction confirmed: ${signature}`,
                    );

                    // Show success message
                    showNotification(
                        `${challengeType.replace("_", "-")} challenge completed! ${data.rewardAmount} SHSY claimed.`,
                        "success",
                    );

                    // Reload challenges and balance
                    await loadStakingChallenges();
                    await fetchTokenBalance();
                } catch (error) {
                    console.error(
                        `Error claiming ${challengeType.replace("_", "-")} challenge reward:`,
                        error,
                    );
                    showNotification(
                        "Failed to claim challenge reward",
                        "error",
                    );
                }
            }

            // Load staking challenges for connected wallet
            async function loadStakingChallenges() {
                if (!walletConnected || !walletAddress) {
                    console.log(
                        "Cannot load challenges - wallet not connected or address missing",
                    );
                    return;
                }

                try {
                    console.log(
                        "Loading challenges for wallet:",
                        walletAddress,
                    );
                    const response = await apiRequest(
                        `/api/dapp/challenges/${walletAddress}`,
                    );
                    const data = await response.json();
                    console.log("Challenge API response:", data);

                    if (data.success) {
                        stakingChallenges = data.challenges || [];
                        challengeEligibility =
                            data.eligibility || challengeEligibility;
                        pendingRewards = data.pendingRewards || [];
                        updateChallengeUI();
                        updatePendingRewardsDisplay();
                        console.log(
                            "Loaded staking challenges:",
                            stakingChallenges,
                        );
                        console.log(
                            "Challenge eligibility:",
                            challengeEligibility,
                        );
                        console.log("Pending rewards:", pendingRewards);

                        // Start timers if challenges exist
                        if (stakingChallenges.length > 0) {
                            startChallengeTimers();
                        }
                    } else {
                        console.error(
                            "Challenge API returned error:",
                            data.error,
                        );
                    }
                } catch (error) {
                    console.error("Error loading staking challenges:", error);
                }
            }

            // Update challenge UI with current progress
            function updateChallengeUI() {
                const challenge10Day = stakingChallenges.find(
                    (c) => c.challengeType === "10_day",
                );
                const challenge30Day = stakingChallenges.find(
                    (c) => c.challengeType === "30_day",
                );

                updateChallengeCard("10", challenge10Day);
                updateChallengeCard("30", challenge30Day);
            }

            // Update individual challenge card
            function updateChallengeCard(type, challenge) {
                const statusEl = document.getElementById(
                    `challenge${type}Status`,
                );
                const progressEl = document.getElementById(
                    `challenge${type}Progress`,
                );
                const progressBarEl = document.getElementById(
                    `challenge${type}ProgressBar`,
                );
                const timerEl = document.getElementById(
                    `challenge${type}Timer`,
                );
                const timeLeftEl = document.getElementById(
                    `challenge${type}TimeLeft`,
                );
                const claimBtn = document.getElementById(
                    `claim${type}DayReward`,
                );
                const rewardEl = document.getElementById(
                    `challenge${type}Reward`,
                );
                const claimButtonTextEl = document.getElementById(
                    `claim${type}ButtonText`,
                );

                if (!challenge || challenge.status === "inactive") {
                    // No active challenge - show eligibility status
                    if (challengeEligibility.isEligible) {
                        statusEl.textContent = "Eligible";
                        statusEl.style.backgroundColor = "#dcfce7";
                        statusEl.style.color = "#16a34a";
                        progressEl.textContent = challengeEligibility.message;
                    } else {
                        statusEl.textContent = "Not Eligible";
                        statusEl.style.backgroundColor = "#fee2e2";
                        statusEl.style.color = "#dc2626";
                        progressEl.textContent = challengeEligibility.message;
                    }
                    progressBarEl.style.width = "0%";
                    timerEl.style.display = "none";
                    claimBtn.style.display = "none";

                    // Clear reward display when no challenge
                    if (rewardEl) {
                        rewardEl.textContent = "Reward: -- SHSY";
                    }
                    return;
                }

                // Update reward amount from API data
                if (challenge.rewardAmount && rewardEl) {
                    const rewardAmount = parseFloat(
                        challenge.rewardAmount,
                    ).toFixed(0);
                    rewardEl.textContent = `Reward: ${rewardAmount} SHSY`;
                }

                // Update claim button text
                if (challenge.rewardAmount && claimButtonTextEl) {
                    const rewardAmount = parseFloat(
                        challenge.rewardAmount,
                    ).toFixed(0);
                    claimButtonTextEl.textContent = `Claim ${rewardAmount} SHSY Reward`;
                }

                const progress = challenge.progress;
                const targetDays = parseInt(type);

                // Update status
                if (
                    challenge.status === "completed" ||
                    challenge.status === "claimed"
                ) {
                    statusEl.textContent =
                        challenge.status === "claimed"
                            ? "Claimed"
                            : "Completed";
                    statusEl.style.backgroundColor = "#dcfce7";
                    statusEl.style.color = "#16a34a";
                } else if (progress.isCompleted) {
                    statusEl.textContent = "Ready to Claim";
                    statusEl.style.backgroundColor = "#fef3c7";
                    statusEl.style.color = "#d97706";
                } else {
                    if (challengeEligibility.isEligible) {
                        statusEl.textContent = "Active";
                    } else {
                        statusEl.textContent = "Not Eligible";
                    }

                    statusEl.style.backgroundColor = "#e0f7fa";
                    statusEl.style.color = "#00c4b4";
                }

                // Update progress (show as days in UI, calculate from minutes from API)
                // Stop progression if completed (whether can claim or not)
                let displayDays, progressPercentage;
                if (
                    challenge.status === "completed" ||
                    progress.isCompleted ||
                    progress.canClaim
                ) {
                    // Freeze progress at completion until claimed
                    displayDays = targetDays;
                    progressPercentage = 100;
                } else if (challenge.status === "claimed") {
                    // Show as completed if claimed
                    displayDays = targetDays;
                    progressPercentage = 100;
                } else {
                    // Normal progression - convert elapsed minutes to days for display
                    const elapsedDays = Math.floor(
                        progress.elapsedMinutes / (60 * 24),
                    );
                    displayDays = Math.min(elapsedDays, targetDays);
                    progressPercentage = Math.min(
                        progress.progressPercentage,
                        100,
                    );
                }

                progressEl.textContent = `Progress: ${displayDays}/${targetDays} days`;
                progressBarEl.style.width = `${progressPercentage}%`;

                // Update timer
                if (
                    challenge.status === "completed" ||
                    progress.isCompleted ||
                    progress.canClaim
                ) {
                    // Show "Ready to claim" message when completed
                    timerEl.style.display = "block";
                    timeLeftEl.textContent = "Ready to claim!";
                    timeLeftEl.style.color = "#d97706";
                    timeLeftEl.style.fontWeight = "bold";
                } else if (
                    challenge.status === "active" &&
                    progress.elapsedMinutes < progress.targetMinutes
                ) {
                    timerEl.style.display = "block";
                    const remainingMinutes = Math.max(
                        0,
                        progress.targetMinutes - progress.elapsedMinutes,
                    );
                    const days = Math.floor(remainingMinutes / (60 * 24));
                    const hours = Math.floor(
                        (remainingMinutes % (60 * 24)) / 60,
                    );
                    const minutes = Math.floor(remainingMinutes % 60);
                    timeLeftEl.textContent = `${days}d ${hours}h ${minutes}m`;
                    timeLeftEl.style.color = "#6b7280";
                    timeLeftEl.style.fontWeight = "normal";
                } else {
                    timerEl.style.display = "none";
                }

                // Update claim button
                if (progress.canClaim && challenge.status === "active") {
                    claimBtn.style.display = "block";
                    claimBtn.onclick = () =>
                        claimChallengeReward(challenge.id, type + "_day");
                } else {
                    claimBtn.style.display = "none";
                }
            }

            // Start challenges when user stakes
            async function startStakingChallenges() {
                if (!walletConnected || !walletAddress) {
                    console.log(
                        "Cannot start challenges - wallet not connected",
                    );
                    return;
                }

                try {
                    console.log(
                        "Starting staking challenges for wallet:",
                        walletAddress,
                    );
                    const response = await apiRequest(
                        "/api/dapp/challenges/start",
                        "POST",
                        {
                            walletAddress: walletAddress,
                        },
                    );

                    const data = await response.json();
                    console.log("Started/updated staking challenges:", data);

                    // Wait a moment for database to commit, then reload challenges
                    setTimeout(async () => {
                        await loadStakingChallenges();
                    }, 500);
                } catch (error) {
                    console.error("Error starting staking challenges:", error);
                }
            }

            // Pause challenges when user withdraws all stakes
            async function pauseStakingChallenges() {
                if (!walletConnected || !walletAddress) {
                    return;
                }

                try {
                    await apiRequest("/api/dapp/challenges/pause", "POST", {
                        walletAddress: walletAddress,
                    });
                    console.log("Staking challenges paused");
                } catch (error) {
                    console.error("Error pausing staking challenges:", error);
                }
            }

            // Resume challenges when user stakes again
            async function resumeStakingChallenges() {
                if (!walletConnected || !walletAddress) {
                    return;
                }

                try {
                    await apiRequest("/api/dapp/challenges/resume", "POST", {
                        walletAddress: walletAddress,
                    });
                    console.log("Staking challenges resumed");
                    await loadStakingChallenges();
                } catch (error) {
                    console.error("Error resuming staking challenges:", error);
                }
            }

            // Start challenge timers for UI updates
            function startChallengeTimers() {
                // Clear existing timers
                Object.values(challengeTimers).forEach((timer) =>
                    clearInterval(timer),
                );
                challengeTimers = {};

                // Update challenges every minute (but stop for completed challenges that can be claimed)
                challengeTimers.main = setInterval(async () => {
                    if (walletConnected && walletAddress) {
                        // Check if all challenges are ready to claim (stop reloading to freeze progression)
                        const allReadyToClaim =
                            stakingChallenges.length > 0 &&
                            stakingChallenges.every(
                                (c) =>
                                    (c.status === "completed" &&
                                        c.progress?.canClaim) ||
                                    c.status === "claimed",
                            );

                        // Always reload if challenges are inactive or not ready to claim yet
                        if (!allReadyToClaim) {
                            await loadStakingChallenges();
                        }
                    }
                }, 60000); // Update every minute
            }

            // Load stats and leaderboard on page load
            loadLeaderboard();
            setInterval(loadLeaderboard, 30000); // Refresh leaderboard every 30 seconds
        </script>
    </body>
</html>
